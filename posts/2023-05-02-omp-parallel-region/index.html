<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Omp Parallel Region | Yac's Log</title><meta name=keywords content="c++,omp,performance"><meta name=description content="The results look suspicious to me&mldr; But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.
Multiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Let&rsquo;s use two example for illustration:
Three loops operating on a vector of size 2^31, e.g.,
for(size_t i = 0; i < vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-05-02-omp-parallel-region/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Omp Parallel Region"><meta property="og:description" content="The results look suspicious to me&mldr; But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.
Multiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Let&rsquo;s use two example for illustration:
Three loops operating on a vector of size 2^31, e.g.,
for(size_t i = 0; i < vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }"><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-05-02-omp-parallel-region/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-02T10:34:19+08:00"><meta property="article:modified_time" content="2023-05-02T10:34:19+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Omp Parallel Region"><meta name=twitter:description content="The results look suspicious to me&mldr; But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.
Multiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Let&rsquo;s use two example for illustration:
Three loops operating on a vector of size 2^31, e.g.,
for(size_t i = 0; i < vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Omp Parallel Region","item":"https://yuang-chen.github.io/posts/2023-05-02-omp-parallel-region/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Omp Parallel Region","name":"Omp Parallel Region","description":"The results look suspicious to me\u0026hellip; But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.\nMultiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Let\u0026rsquo;s use two example for illustration:\nThree loops operating on a vector of size 2^31, e.g.,\nfor(size_t i = 0; i \u0026lt; vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }","keywords":["c++","omp","performance"],"articleBody":"The results look suspicious to meâ€¦ But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.\nMultiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Letâ€™s use two example for illustration:\nThree loops operating on a vector of size 2^31, e.g.,\nfor(size_t i = 0; i \u003c vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }\nCase 2: three separate parallel region are built for each loop via omp parallel for.\nThe time difference:\n#parallel region time (ms) one 2.59 three 0.57 The result is contradictory to our intuition, as we expect a big parallel region (case 1) to run faster than three regions (case 2). The contradition results from the expensive overhead of building the big parallel region. By breaking down the performance and measuring the three loops respetively, we obtain:\nloop one three init 2.298 / 1st 0.017 0.057 2nd 0.011 0.032 3rd 0.020 0.030 The initialization of a parallel region is extremely expensive (i.e., 2.298ms), which consumes even more time than the computational tasks in our case. Within the parallel region of case 1, each loop costs shorter than their counterparts in case 2. Thus, together with the initialization phase, the computing tasks in case 1 deliver suboptimal performance than the sum of individual regions.\n","wordCount":"238","inLanguage":"en","datePublished":"2023-05-02T10:34:19+08:00","dateModified":"2023-05-02T10:34:19+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-05-02-omp-parallel-region/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Omp Parallel Region</h1><div class=post-meta><span title='2023-05-02 10:34:19 +0800 CST'>May 2, 2023</span>&nbsp;Â·&nbsp;238 words&nbsp;Â·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#multiple-parallel-regions>Multiple Parallel Regions</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The results look suspicious to me&mldr; But I wrote down this note many days ago ðŸ¦¥. Maybe I need to evaluate it again.</p><h3 id=multiple-parallel-regions>Multiple Parallel Regions<a hidden class=anchor aria-hidden=true href=#multiple-parallel-regions>#</a></h3><p>The cost of constructing parallel region is expensive in OpenMP. Let&rsquo;s use two example for illustration:</p><p>Three loops operating on a vector of size 2^31, e.g.,</p><pre tabindex=0><code>for(size_t i = 0; i &lt; vec.size(); i++) 
  vec[i] += 1, 
  vec[i] *= 0.9,
  vec[i] /= 7,
</code></pre><p>Case 1: a large parallel region including the three loops by <code>omp parallel { omp for }</code><br>Case 2: three separate parallel region are built for each loop via <code>omp parallel for</code>.</p><p>The time difference:</p><table><thead><tr><th>#parallel region</th><th>time (ms)</th></tr></thead><tbody><tr><td><code>one</code></td><td>2.59</td></tr><tr><td><strong><code>three</code></strong></td><td>0.57</td></tr></tbody></table><p>The result is contradictory to our intuition, as we expect a big parallel region (case 1) to run faster than three regions (case 2). The contradition results from the expensive overhead of building the big parallel region. By breaking down the performance and measuring the three loops respetively, we obtain:</p><table><thead><tr><th>loop</th><th>one</th><th>three</th></tr></thead><tbody><tr><td>init</td><td>2.298</td><td>/</td></tr><tr><td>1st</td><td>0.017</td><td>0.057</td></tr><tr><td>2nd</td><td>0.011</td><td>0.032</td></tr><tr><td>3rd</td><td>0.020</td><td>0.030</td></tr></tbody></table><p>The initialization of a parallel region is extremely expensive (i.e., 2.298ms), which consumes even more time than the computational tasks in our case. Within the parallel region of case 1, each loop costs shorter than their counterparts in case 2. Thus, together with the initialization phase, the computing tasks in case 1 deliver suboptimal performance than the sum of individual regions.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>c++</a></li><li><a href=https://yuang-chen.github.io/tags/omp/>omp</a></li><li><a href=https://yuang-chen.github.io/tags/performance/>performance</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>