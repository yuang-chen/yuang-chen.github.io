<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Scope Guard | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-08-29-scope-guard/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Scope Guard"><meta property="og:description" content="Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-08-29-scope-guard/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-29T10:27:54+08:00"><meta property="article:modified_time" content="2023-08-29T10:27:54+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Scope Guard"><meta name=twitter:description content="Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Scope Guard","item":"https://yuang-chen.github.io/posts/2023-08-29-scope-guard/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Scope Guard","name":"Scope Guard","description":"Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.\nRAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {}).","keywords":["C++"],"articleBody":"Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.\nRAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {}).\nHere’s a breakdown of RAII:\nResource Acquisition: When an object is created, it acquires a specific resource. Initialization: The resource acquisition is done during the object’s construction (i.e., when it’s initialized). RAII ensures the following:\nResources are acquired in a deterministic manner (during object creation). Resources are released in a deterministic manner (during object destruction). Exception safety, as resources are automatically cleaned up even if an exception is thrown. Example A simple example of RAII is the use of std::unique_ptr to manage dynamically allocated memory:\nvoid exampleFunction() { std::unique_ptr\u003cint\u003e p(new int(5)); // Resource (memory) is acquired and \"owned\" by p. // Do some operations with p... } // p goes out of scope and its destructor is called, which deletes the memory. No memory leak! This RAII behavior is contrasted with manual memory management where you’d have to remember to call delete:\nvoid nonRAIIExample() { int* p = new int(5); // Memory is acquired. // Do some operations... delete p; // You have to manually release the memory. Risky! } Implementation of a Scope Guard Requirements Three requirements are listed in the following code block for implementing the scope guard.\n#include #include #include #include #include int main() { { // Requirement 0: Support lambda FILE * fp = nullptr; try{ fp = fopen(\"test.txt\",\"a\"); auto guard = scope_guard([\u0026] { fclose(fp); fp = nullptr; }); throw std::runtime_error{\"Test\"}; } catch(std::exception \u0026 e){ puts(e.what()); } assert(fp == nullptr); } puts(\"----------\"); { // Requirement 1: Support function object invocation // \u0026 binding arguments to the callable. struct Test { void operator()(X* x) { delete x; } } t; auto x = new X{}; auto guard = scope_guard(t, x); } puts(\"----------\"); { // Requirement 2: Support member functions and std::ref. auto x = new X{}; { struct Test { void f(X*\u0026 px) { delete px; px = nullptr; } } t; auto guard = scope_guard{\u0026Test::f, \u0026t, std::ref(x)}; } assert(x == nullptr); } Solutions Naive To meet the basic requirement, all you need to do is keep the lambda stored within a std::function:\n// naive solution class scope_guard { public: explicit scope_guard(std::function\u003cvoid()\u003e onExitScope) : onExitScope_(onExitScope) {} ~scope_guard() { on_exit_scope(); } private: std::function\u003cvoid()\u003e on_exit_scope; }; Conventional However, for requirements 2 and 3, things get trickier. We need to deal with more complex situations like binding arguments and passing by reference. As a result, we’re stepping up our game with an upgraded solution:\n// conventional solution class scope_guard { public: template \u003ctypename Callable, typename... Args\u003e scope_guard(Callable\u0026\u0026 func, Args\u0026\u0026... args) { on_exit_scope = std::bind(std::forward\u003cCallable\u003e(func), std::forward\u003cArgs\u003e(args)...); } ~scope_guard() { on_exit_scope(); } private: std::function\u003cvoid()\u003e on_exit_scope; }; Fancy However, this simple solution isn’t cool anymore. The use of std::bind dates back to the old c++11 days, but we’re now in the modern world of c++23. Let’s modernize (and over-complicate) the code:\n// fancy solution class scope_guard { public: template\u003ctypename Callable, typename... Args\u003e requires std::invocable\u003cCallable, std::unwrap_reference_t\u003cArgs\u003e...\u003e scope_guard(Func\u0026\u0026 func, Args\u0026\u0026...args) :f{ [func = std::forward\u003cFunc\u003e(func), ...args = std::forward\u003cArgs\u003e(args)]() mutable { std::invoke(std::forward\u003cstd::decay_t\u003cFunc\u003e\u003e(func), std::unwrap_reference_t\u003cArgs\u003e(std::forward\u003cArgs\u003e(args))...); } }{} ~scope_guard() { on_exit_scope(); } // Prevent copying, but allow moves. scope_guard(const scope_guard\u0026) = delete; scope_guard\u0026 operator=(const scope_guard\u0026) = delete; scope_guard(scope_guard\u0026\u0026) = default; scope_guard\u0026 operator=(scope_guard\u0026\u0026) = default; private: std::function\u003cvoid()\u003e on_exit_scope; }; ","wordCount":"629","inLanguage":"en","datePublished":"2023-08-29T10:27:54+08:00","dateModified":"2023-08-29T10:27:54+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-08-29-scope-guard/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Scope Guard</h1><div class=post-meta><span title='2023-08-29 10:27:54 +0800 CST'>August 29, 2023</span>&nbsp;·&nbsp;629 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#example>Example</a></li><li><a href=#implementation-of-a-scope-guard>Implementation of a <code>Scope Guard</code></a><ul><li><a href=#requirements>Requirements</a></li><li><a href=#solutions>Solutions</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p><strong>Scope Guard</strong> is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using <em>object</em> lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.</p><p><strong>RAII</strong> (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces <code>{}</code>).</p><p>Here&rsquo;s a breakdown of RAII:</p><ul><li><strong>Resource Acquisition</strong>: When an object is created, it acquires a specific resource.</li><li><strong>Initialization</strong>: The resource acquisition is done during the object&rsquo;s construction (i.e., when it&rsquo;s initialized).</li></ul><p>RAII ensures the following:</p><ol><li>Resources are <strong>acquired</strong> in a deterministic manner (during object creation).</li><li>Resources are <strong>released</strong> in a deterministic manner (during object destruction).</li><li>Exception safety, as resources are automatically cleaned up even if an exception is thrown.</li></ol><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>A simple example of RAII is the use of <code>std::unique_ptr</code> to manage dynamically allocated memory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>exampleFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>5</span><span class=p>));</span>  <span class=c1>// Resource (memory) is acquired and &#34;owned&#34; by p.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do some operations with p...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>}</span>  <span class=c1>// p goes out of scope and its destructor is called, which deletes the memory. No memory leak!
</span></span></span></code></pre></div><p>This RAII behavior is contrasted with manual memory management where you&rsquo;d have to remember to call delete:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>nonRAIIExample</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>  <span class=c1>// Memory is acquired.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do some operations...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>  <span class=c1>// You have to manually release the memory. Risky!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=implementation-of-a-scope-guard>Implementation of a <code>Scope Guard</code><a hidden class=anchor aria-hidden=true href=#implementation-of-a-scope-guard>#</a></h2><h3 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h3><p>Three requirements are listed in the following code block for implementing the <code>scope guard</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cassert&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdexcept&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;functional&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Requirement 0: Support lambda
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>FILE</span> <span class=o>*</span> <span class=n>fp</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>fp</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>,</span><span class=s>&#34;a&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>guard</span> <span class=o>=</span> <span class=n>scope_guard</span><span class=p>([</span><span class=o>&amp;</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>fp</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>{</span><span class=s>&#34;Test&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=o>&amp;</span> <span class=n>e</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>puts</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>fp</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;----------&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Requirement 1: Support function object invocation
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// &amp; binding arguments to the callable.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=nc>Test</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>void</span> <span class=k>operator</span><span class=p>()(</span><span class=n>X</span><span class=o>*</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>delete</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>x</span> <span class=o>=</span> <span class=k>new</span> <span class=n>X</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>guard</span> <span class=o>=</span> <span class=n>scope_guard</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;----------&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Requirement 2: Support member functions and std::ref.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>auto</span> <span class=n>x</span> <span class=o>=</span> <span class=k>new</span> <span class=n>X</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>struct</span> <span class=nc>Test</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>X</span><span class=o>*&amp;</span> <span class=n>px</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>delete</span> <span class=n>px</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>px</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>guard</span> <span class=o>=</span> <span class=n>scope_guard</span><span class=p>{</span><span class=o>&amp;</span><span class=n>Test</span><span class=o>::</span><span class=n>f</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>x</span><span class=p>)};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h3 id=solutions>Solutions<a hidden class=anchor aria-hidden=true href=#solutions>#</a></h3><h4 id=naive>Naive<a hidden class=anchor aria-hidden=true href=#naive>#</a></h4><p>To meet the basic requirement, all you need to do is keep the lambda stored within a <code>std::function</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// naive solution
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>scope_guard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>scope_guard</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>onExitScope</span><span class=p>)</span> <span class=o>:</span> <span class=n>onExitScope_</span><span class=p>(</span><span class=n>onExitScope</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>scope_guard</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>on_exit_scope</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>on_exit_scope</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=conventional>Conventional<a hidden class=anchor aria-hidden=true href=#conventional>#</a></h4><p>However, for requirements 2 and 3, things get trickier. We need to deal with more complex situations like binding arguments and passing by reference. As a result, we&rsquo;re stepping up our game with an upgraded solution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// conventional solution
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>scope_guard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Callable</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>scope_guard</span><span class=p>(</span><span class=n>Callable</span><span class=o>&amp;&amp;</span> <span class=n>func</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>on_exit_scope</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bind</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Callable</span><span class=o>&gt;</span><span class=p>(</span><span class=n>func</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>scope_guard</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>on_exit_scope</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>on_exit_scope</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=fancy>Fancy<a hidden class=anchor aria-hidden=true href=#fancy>#</a></h4><p>However, this simple solution isn&rsquo;t cool anymore. The use of <code>std::bind</code> dates back to the old <code>c++11</code> days, but we&rsquo;re now in the modern world of <code>c++23</code>. Let&rsquo;s modernize (and over-complicate) the code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// fancy solution
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>scope_guard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Callable</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span> <span class=n>std</span><span class=o>::</span><span class=n>invocable</span><span class=o>&lt;</span><span class=n>Callable</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unwrap_reference_t</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>scope_guard</span><span class=p>(</span><span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>func</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span><span class=n>args</span><span class=p>)</span> <span class=o>:</span><span class=n>f</span><span class=p>{</span> <span class=p>[</span><span class=n>func</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;</span><span class=p>(</span><span class=n>func</span><span class=p>),</span> <span class=p>...</span><span class=n>args</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)]()</span> <span class=k>mutable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>invoke</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>Func</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>func</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>unwrap_reference_t</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>))...);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=p>}{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>scope_guard</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>on_exit_scope</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Prevent copying, but allow moves.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>scope_guard</span><span class=p>(</span><span class=k>const</span> <span class=n>scope_guard</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>scope_guard</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>scope_guard</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>scope_guard</span><span class=p>(</span><span class=n>scope_guard</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>scope_guard</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>scope_guard</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>on_exit_scope</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>c++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>