<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Performance Comparisons: Half, Half2 and Float | Yac's Log</title><meta name=keywords content="CUDA"><meta name=description content="A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 elements, but for the half2 type, two elements were packed into a single vector entry. Hence, two randomness are tested for half2 type: random access per half2 and random access per half.
Access Type Data Type Vector Size Allocated Memory Time (ms) Random half 1M 2MB 4."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2024-09-12-half-half2-float/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Performance Comparisons: Half, Half2 and Float"><meta property="og:description" content="A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 elements, but for the half2 type, two elements were packed into a single vector entry. Hence, two randomness are tested for half2 type: random access per half2 and random access per half.
Access Type Data Type Vector Size Allocated Memory Time (ms) Random half 1M 2MB 4."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2024-09-12-half-half2-float/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-12T18:49:29+08:00"><meta property="article:modified_time" content="2024-09-12T18:49:29+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Performance Comparisons: Half, Half2 and Float"><meta name=twitter:description content="A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 elements, but for the half2 type, two elements were packed into a single vector entry. Hence, two randomness are tested for half2 type: random access per half2 and random access per half.
Access Type Data Type Vector Size Allocated Memory Time (ms) Random half 1M 2MB 4."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Performance Comparisons: Half, Half2 and Float","item":"https://yuang-chen.github.io/posts/2024-09-12-half-half2-float/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Performance Comparisons: Half, Half2 and Float","name":"Performance Comparisons: Half, Half2 and Float","description":"A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 elements, but for the half2 type, two elements were packed into a single vector entry. Hence, two randomness are tested for half2 type: random access per half2 and random access per half.\nAccess Type Data Type Vector Size Allocated Memory Time (ms) Random half 1M 2MB 4.","keywords":["CUDA"],"articleBody":"A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 elements, but for the half2 type, two elements were packed into a single vector entry. Hence, two randomness are tested for half2 type: random access per half2 and random access per half.\nAccess Type Data Type Vector Size Allocated Memory Time (ms) Random half 1M 2MB 4.275200 Random float 1M 4MB 4.088096 Random by half half2 0.5M 2MB 4.011008 Random by half2 half2 0.5M 2MB 2.325184 Sequential half 1M 2MB 0.755712 Sequential half2 0.5M 2MB 0.707488 Sequential float 1M 4MB 0.794912 The performance results can be explained by the tradeoff between memory alignment and memory footprint.\nRandom Access: Speed: half2-by-half2 \u003e half2-by-half \u003e float \u003e half\nrandom with half is slowest: Despite its smaller size, half suffers from alignment issues. GPUs often prefer 32-bit aligned memory accesses, so accessing 16-bit values may require additional operations. random with float is slow: float requires more memory than half, but it has natural alignment, so it is slightly faster than half. random with half2 by half is slow too: The overhead of packing and unpacking values negates the benefits of memory alignment. random with half2 by half2 is fastest: It packs two half values into a 32-bit word, allowing for more efficient memory access. Sequential Access: Speed: half2 \u003e float \u003e half\nhalf2 is the fastest: Packed memory access and smaller memory footprint lead to the best performance. half is slower: Small memory footprint, but it is slower than half2 due to alignment issues. float is the slowest: float requires more memory than the half and half2 types, thus needs more time to transfer. ","wordCount":"290","inLanguage":"en","datePublished":"2024-09-12T18:49:29+08:00","dateModified":"2024-09-12T18:49:29+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2024-09-12-half-half2-float/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Performance Comparisons: Half, Half2 and Float</h1><div class=post-meta><span title='2024-09-12 18:49:29 +0800 CST'>September 12, 2024</span>&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p>A performance evaluation is conducted on an Nvidia L40, comparing the 100-iteration access times of device vectors with half, half2, and float types. Each vector was initialized with 1024*1024 <em>elements</em>, but for the <code>half2</code> type, two elements were packed into a single vector entry. Hence, two randomness are tested for <code>half2</code> type: random access per <code>half2</code> and random access per <code>half</code>.</p><table><thead><tr><th>Access Type</th><th>Data Type</th><th>Vector Size</th><th>Allocated Memory</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Random</td><td>half</td><td>1M</td><td>2MB</td><td>4.275200</td></tr><tr><td>Random</td><td>float</td><td>1M</td><td>4MB</td><td>4.088096</td></tr><tr><td>Random by half</td><td>half2</td><td>0.5M</td><td>2MB</td><td>4.011008</td></tr><tr><td>Random by half2</td><td>half2</td><td>0.5M</td><td>2MB</td><td>2.325184</td></tr><tr><td>Sequential</td><td>half</td><td>1M</td><td>2MB</td><td>0.755712</td></tr><tr><td>Sequential</td><td>half2</td><td>0.5M</td><td>2MB</td><td>0.707488</td></tr><tr><td>Sequential</td><td>float</td><td>1M</td><td>4MB</td><td>0.794912</td></tr></tbody></table><p>The performance results can be explained by the tradeoff between <em>memory alignment</em> and <em>memory footprint</em>.</p><h3 id=random-access>Random Access:<a hidden class=anchor aria-hidden=true href=#random-access>#</a></h3><p><em><strong>Speed</strong></em>: half2-by-half2 > half2-by-half > float > half</p><ul><li><strong>random with half is slowest</strong>: Despite its smaller size, <code>half</code> suffers from alignment issues. GPUs often prefer 32-bit aligned memory accesses, so accessing 16-bit values may require additional operations.</li><li><strong>random with float is slow</strong>: <code>float</code> requires more memory than <code>half</code>, but it has natural alignment, so it is slightly faster than half.</li><li><strong>random with half2 by half is slow too</strong>: The overhead of packing and unpacking values negates the benefits of memory alignment.</li><li><strong>random with half2 by half2 is fastest</strong>: It packs two <code>half</code> values into a 32-bit word, allowing for more efficient memory access.</li></ul><h3 id=sequential-access>Sequential Access:<a hidden class=anchor aria-hidden=true href=#sequential-access>#</a></h3><p><em><strong>Speed</strong></em>: half2 > float > half</p><ul><li><strong>half2 is the fastest</strong>: Packed memory access and smaller memory footprint lead to the best performance.</li><li><strong>half is slower</strong>: Small memory footprint, but it is slower than <code>half2</code> due to alignment issues.</li><li><strong>float is the slowest</strong>: <code>float</code> requires more memory than the <code>half</code> and <code>half2</code> types, thus needs more time to transfer.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/cuda/>CUDA</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>