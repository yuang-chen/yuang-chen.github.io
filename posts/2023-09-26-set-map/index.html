<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Set & Map | Yac's Log</title><meta name=keywords content><meta name=description content="Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it&rsquo;s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left < node < node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.
RBT are characterized as follows:
Property
A node is either red or black."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-09-26-set-map/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Set & Map"><meta property="og:description" content="Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it&rsquo;s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left < node < node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.
RBT are characterized as follows:
Property
A node is either red or black."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-09-26-set-map/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-26T00:09:48+08:00"><meta property="article:modified_time" content="2023-09-26T00:09:48+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Set & Map"><meta name=twitter:description content="Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it&rsquo;s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left < node < node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.
RBT are characterized as follows:
Property
A node is either red or black."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Set \u0026 Map","item":"https://yuang-chen.github.io/posts/2023-09-26-set-map/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Set \u0026 Map","name":"Set \u0026 Map","description":"Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it\u0026rsquo;s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left \u0026lt; node \u0026lt; node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.\nRBT are characterized as follows:\nProperty\nA node is either red or black.","keywords":[],"articleBody":"Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it’s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left \u003c node \u003c node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.\nRBT are characterized as follows:\nProperty\nA node is either red or black. The root and leaves (nil, nullptr node) are always black. If a node is red, then its children are black. All paths from a node to its leaves contain the same number of black nodes. The longest path from the root to a leaf is no more than twice as long as the shortest path from the root to a leaf. – The shortest path: all black nodes. – The longest path: alternate red and black nodes. Basic Operations:\nInsert O(logN), requires rotation Remove O(logN), requires rotation Search O(logN) Rotation:\nalters the structure of the tree by rearranging subtrees goal is to decrease the height of the tree – maximum height: log(N) – larger subtrees up, smaller subtrees down left rotation: clockwise rotation right rotation: counterclockwise rotation Insertion todo\nDeletion todo\nDue to the inefficiency of RBT, std::set and std::map are usually replaced with std::unordered_set and std::unordered_map, which utilize a hashing strategy to perform operations in constant time, O(1).\nCode The implementation of RBT can indeed be complex and intricate, making it challenging to remember all the details. With the assistance of ChatGPT, here is an example code snippet:\n#include enum Color { RED, BLACK }; template \u003ctypename T\u003e struct Node { //K key; for map T value; Color color; Node* left; Node* right; Node* parent; Node(Color c, Node* p = nullptr, T val) : color(c), left(nullptr), right(nullptr), parent(p), value(val) { } }; template \u003ctypename T\u003e class RedBlackTree { private: Node* root; void deleteTree(Node* node) { if(node) { deleteTree(node-\u003eleft); deleteTree(node-\u003eright); delete node; } } //! very annoying to write // GOAL: node x become the [left child] of its [right child] y // totally six pointers need to be updated void rotateLeft(Node* x) { Node* y = x-\u003eright; x-\u003eright = y-\u003eleft; //the left child of y will become the new right child of x. if(y-\u003eleft != nullptr) { y-\u003eleft-\u003eparent = x; // if y had a left child, update its parent pointer to x. } y-\u003eparent = x-\u003eparent; // update y's parent to x's parent. if(x-\u003eparent == nullptr) { root = y; // if x was the root, then y becomes the new root. } else if(x == x-\u003eparent-\u003eleft) { //if x was the left child of its parent, then update the left child of x's parent to y x-\u003eparent-\u003eleft = y; } else { //if x was the right child of its parent, update the right child of x's parent to y x-\u003eparent-\u003eright = y; } y-\u003eleft = x; // make x the left child of y x-\u003eparent = y; // update the parent of x to y. } // symmetric operations of rotateLeft // GOAL: node y become the [right child] of its [left child] x void rotateRight(Node* y) { Node* x = y-\u003eleft; y-\u003eleft = x-\u003eright; if(x-\u003eright != nullptr) { x-\u003eright-\u003eparent = y; } x-\u003eparent = y-\u003eparent; if(y-\u003eparent == nullptr) { root = x; } else if(y == y-\u003eparent-\u003eleft) { y-\u003eparent-\u003eleft = x; } else { y-\u003eparent-\u003eright = x; } x-\u003eright = y; y-\u003eparent = x; } void fixViolations(Node* x) { Node* parent = nullptr; Node* grandparent = nullptr; while((x != root) \u0026\u0026 (x-\u003ecolor != BLACK) \u0026\u0026 (x-\u003eparent-\u003ecolor == RED)) { parent = x-\u003eparent; grandparent = parent-\u003eparent; // Case A: Parent is left child of grandparent if(parent == grandparent-\u003eleft) { Node* uncle = grandparent-\u003eright; if(uncle \u0026\u0026 uncle-\u003ecolor == RED) // uncle is RED { grandparent-\u003ecolor = RED; parent-\u003ecolor = BLACK; uncle-\u003ecolor = BLACK; x = grandparent; } else { if(x == parent-\u003eright) // uncle is BLACK and x is right child { rotateLeft(parent); x = parent; parent = x-\u003eparent; } rotateRight(grandparent); std::swap(parent-\u003ecolor, grandparent-\u003ecolor); x = parent; } } else { // Case B: Parent is right child of grandparent Node* uncle = grandparent-\u003eleft; if(uncle \u0026\u0026 uncle-\u003ecolor == RED) // uncle is RED { grandparent-\u003ecolor = RED; parent-\u003ecolor = BLACK; uncle-\u003ecolor = BLACK; x = grandparent; } else { if(x == parent-\u003eleft) // uncle is BLACK and x is left child { rotateRight(parent); x = parent; parent = x-\u003eparent; } rotateLeft(grandparent); std::swap(parent-\u003ecolor, grandparent-\u003ecolor); x = parent; } } } root-\u003ecolor = BLACK; } void insert(Node*\u0026 node, Node* parent, const T\u0026 value) { if(node == nullptr) { node = new Node(RED, parent, value); // insert the node and color it RED fixViolations(node); return; } if(value == node-\u003evalue) { return; // no need to insert } if(value \u003c node-\u003evalue) { insert(node-\u003eleft, node, value); } else { insert(node-\u003eright, node, value); } } public: RedBlackTree() : root(nullptr) {} ~RedBlackTree() { deleteTree(root); } }; template \u003ctypename T\u003e class set { private: RedBlackTree\u003cT\u003e tree; public: void insert(const T\u0026 value) { tree.insert(value); } bool find(const T\u0026 value) { return tree.find(value); } }; template \u003ctypename K, typename V\u003e struct Pair { K key; V value; Pair(const K\u0026 k, const V\u0026 v) : key(k), value(v) {} bool operator\u003c(const Pair\u0026 rhs) const { return key \u003c rhs.key; } }; template \u003ctypename K, typename V\u003e class map { private: RedBlackTree\u003cPair\u003cK, V\u003e\u003e tree; public: void insert(const K\u0026 key, const V\u0026 value) { tree.insert(Pair\u003cK, V\u003e(key, value)); } void find(const K\u0026 key) { return tree.find(Pair\u003cK, V\u003e(key, V())); } }; int main() { set\u003cint\u003e my_set; my_set.insert(5); my_set.insert(3); my_set.insert(7); return 0; } ","wordCount":"920","inLanguage":"en","datePublished":"2023-09-26T00:09:48+08:00","dateModified":"2023-09-26T00:09:48+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-09-26-set-map/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Set & Map</h1><div class=post-meta><span title='2023-09-26 00:09:48 +0800 HKT'>September 26, 2023</span>&nbsp;·&nbsp;920 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h2 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h2><p>Both <code>std::set</code> and <code>std::map</code> are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it&rsquo;s ensured that the values (for <code>std::set</code>) or keys (for <code>std::map</code>) adhere to the following condition: <code>node→left &lt; node &lt; node→right</code>. Consequently, the RBT are considered ordered, so <code>std::set</code> and <code>std::map</code> are called ordered containers.</p><p>RBT are characterized as follows:</p><p><strong>Property</strong></p><ol><li>A node is either red or black.</li><li>The root and leaves (nil, nullptr node) are always black.</li><li>If a node is red, then its children are black.</li><li>All paths from a node to its leaves contain the same number of black nodes.</li><li>The longest path from the root to a leaf is no more than twice as long as the shortest path from the root to a leaf.
&ndash; The shortest path: all black nodes.
&ndash; The longest path: alternate red and black nodes.</li></ol><p><strong>Basic Operations</strong>:</p><ol><li>Insert O(logN), requires rotation</li><li>Remove O(logN), requires rotation</li><li>Search O(logN)</li></ol><p><strong>Rotation</strong>:</p><ol><li>alters the structure of the tree by rearranging subtrees</li><li>goal is to decrease the height of the tree
&ndash; maximum height: log(N)
&ndash; larger subtrees up, smaller subtrees down</li><li>left rotation: clockwise rotation</li><li>right rotation: counterclockwise rotation</li></ol><p><strong>Insertion</strong>
<code>todo</code></p><p><strong>Deletion</strong>
<code>todo</code></p><p>Due to the inefficiency of RBT, <code>std::set</code> and <code>std::map</code> are usually replaced with <code>std::unordered_set</code> and <code>std::unordered_map</code>, which utilize a hashing strategy to perform operations in constant time, O(1).</p><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p>The implementation of RBT can indeed be complex and intricate, making it challenging to remember all the details. With the assistance of ChatGPT, here is an example code snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Color</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>RED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>BLACK</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//K   key; for map
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>T</span>     <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Color</span> <span class=n>color</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=p>(</span><span class=n>Color</span> <span class=n>c</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>,</span> <span class=n>T</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>color</span><span class=p>(</span><span class=n>c</span><span class=p>),</span> <span class=n>left</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>right</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>parent</span><span class=p>(</span><span class=n>p</span><span class=p>),</span> <span class=n>value</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RedBlackTree</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>deleteTree</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>deleteTree</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>deleteTree</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//! very annoying to write
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// GOAL: node x become the [left child] of its [right child] y
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// totally six pointers need to be updated
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>rotateLeft</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>y</span>  <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>    <span class=c1>//the left child of y will become the new right child of x.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// if y had a left child, update its parent pointer to x.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>    <span class=c1>// update y&#39;s parent to x&#39;s parent.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>root</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>    <span class=c1>// if x was the root, then y becomes the new root.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>    <span class=c1>//if x was the left child of its parent, then update the left child of x&#39;s parent to y
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>    <span class=c1>//if x was the right child of its parent, update the right child of x&#39;s parent to y
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span>   <span class=o>=</span> <span class=n>x</span><span class=p>;</span>    <span class=c1>// make x the left child of y
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>    <span class=c1>// update the parent of x to y.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// symmetric operations of rotateLeft
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// GOAL: node y become the [right child] of its [left child] x
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>rotateRight</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>x</span> <span class=o>=</span> <span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>root</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>y</span> <span class=o>==</span> <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>-&gt;</span><span class=n>right</span>  <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>fixViolations</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>parent</span>      <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>grandparent</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>((</span><span class=n>x</span> <span class=o>!=</span> <span class=n>root</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>!=</span> <span class=n>BLACK</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>==</span> <span class=n>RED</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>parent</span>      <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>grandparent</span> <span class=o>=</span> <span class=n>parent</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Case A: Parent is left child of grandparent
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span><span class=p>(</span><span class=n>parent</span> <span class=o>==</span> <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>*</span> <span class=n>uncle</span> <span class=o>=</span> <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>uncle</span> <span class=o>&amp;&amp;</span> <span class=n>uncle</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>==</span> <span class=n>RED</span><span class=p>)</span>    <span class=c1>// uncle is RED
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>=</span> <span class=n>RED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>parent</span><span class=o>-&gt;</span><span class=n>color</span>      <span class=o>=</span> <span class=n>BLACK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>uncle</span><span class=o>-&gt;</span><span class=n>color</span>       <span class=o>=</span> <span class=n>BLACK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>x</span>                  <span class=o>=</span> <span class=n>grandparent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>parent</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)</span>    <span class=c1>// uncle is BLACK and x is right child
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>rotateLeft</span><span class=p>(</span><span class=n>parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span>      <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=n>rotateRight</span><span class=p>(</span><span class=n>grandparent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>color</span><span class=p>,</span> <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>x</span> <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>    <span class=c1>// Case B: Parent is right child of grandparent
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span><span class=o>*</span> <span class=n>uncle</span> <span class=o>=</span> <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>uncle</span> <span class=o>&amp;&amp;</span> <span class=n>uncle</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>==</span> <span class=n>RED</span><span class=p>)</span>    <span class=c1>// uncle is RED
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>=</span> <span class=n>RED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>parent</span><span class=o>-&gt;</span><span class=n>color</span>      <span class=o>=</span> <span class=n>BLACK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>uncle</span><span class=o>-&gt;</span><span class=n>color</span>       <span class=o>=</span> <span class=n>BLACK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>x</span>                  <span class=o>=</span> <span class=n>grandparent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>parent</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>    <span class=c1>// uncle is BLACK and x is left child
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>rotateRight</span><span class=p>(</span><span class=n>parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span>      <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span> <span class=o>=</span> <span class=n>x</span><span class=o>-&gt;</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=n>rotateLeft</span><span class=p>(</span><span class=n>grandparent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>parent</span><span class=o>-&gt;</span><span class=n>color</span><span class=p>,</span> <span class=n>grandparent</span><span class=o>-&gt;</span><span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>x</span> <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>-&gt;</span><span class=n>color</span> <span class=o>=</span> <span class=n>BLACK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>Node</span><span class=o>*&amp;</span> <span class=n>node</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span> <span class=n>parent</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=p>(</span><span class=n>RED</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>    <span class=c1>// insert the node and color it RED
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>fixViolations</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>    <span class=c1>// no need to insert
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>insert</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>insert</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>RedBlackTree</span><span class=p>()</span> <span class=o>:</span> <span class=n>root</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>RedBlackTree</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>deleteTree</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>set</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>RedBlackTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>tree</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>find</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tree</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=p>,</span> <span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Pair</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>K</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>V</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Pair</span><span class=p>(</span><span class=k>const</span> <span class=n>K</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>,</span> <span class=k>const</span> <span class=n>V</span><span class=o>&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=o>:</span> <span class=n>key</span><span class=p>(</span><span class=n>k</span><span class=p>),</span> <span class=n>value</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>Pair</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>key</span> <span class=o>&lt;</span> <span class=n>rhs</span><span class=p>.</span><span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=p>,</span> <span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>map</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>RedBlackTree</span><span class=o>&lt;</span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;&gt;</span> <span class=n>tree</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>insert</span><span class=p>(</span><span class=k>const</span> <span class=n>K</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>V</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tree</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>find</span><span class=p>(</span><span class=k>const</span> <span class=n>K</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tree</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>V</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>my_set</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>my_set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>my_set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>my_set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>