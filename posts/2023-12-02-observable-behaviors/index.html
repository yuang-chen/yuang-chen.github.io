<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Observable Behaviors | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="What is Observable Behavior & Related Issues The term observable behavior, according to the standard, means the following:
— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.
— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-12-02-observable-behaviors/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Observable Behaviors"><meta property="og:description" content="What is Observable Behavior & Related Issues The term observable behavior, according to the standard, means the following:
— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.
— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-12-02-observable-behaviors/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-02T18:12:37+08:00"><meta property="article:modified_time" content="2023-12-02T18:12:37+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Observable Behaviors"><meta name=twitter:description content="What is Observable Behavior & Related Issues The term observable behavior, according to the standard, means the following:
— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.
— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Observable Behaviors","item":"https://yuang-chen.github.io/posts/2023-12-02-observable-behaviors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Observable Behaviors","name":"Observable Behaviors","description":"What is Observable Behavior \u0026amp; Related Issues The term observable behavior, according to the standard, means the following:\n— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.\n— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.","keywords":["C++"],"articleBody":"What is Observable Behavior \u0026 Related Issues The term observable behavior, according to the standard, means the following:\n— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.\n— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.\n— The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.\nThe “as-if rule” is strongly related, in short, any code transformation is allowed that does not change the observable behavior of the program.\nThe C++ standard precisely defines the observable behavior of every C++ program that does not fall into one of the following classes:\nill-formed ill-formed, no diagnostic required implementation-defined behaviour unspecified behaviour undefined behaviour Ill-Formed: The program has syntax errors and/or diagnosable semantic errors. The compiler will tell you about them. The violated rules are written in the standard with either shall, shall not or ill-formed.\nIll-Formed, No Diagnostic Required (IFNDR): There will be no compiler errors. The program doesn’t have syntactic errors, only semantic ones, but in general, they are not diagnosable by the compiler. These semantic errors are either detectable at link time, or if the program is executed, it results in undefined behavior.\nImplementation-Defined Behavior: This is behavior that the C++ standard does not define explicitly, leaving it up to the compiler or the runtime environment to decide how to implement it. The compiler documentation typically documents how it handles these situations. Examples include the size of an int or the rounding behavior of floating-point types.\nUnspecified Behavior: This refers to behavior that the standard allows to vary between different implementations, but unlike implementation-defined behavior, the compiler is not required to document how it chooses to act. For instance, the order in which function arguments are evaluated is unspecified.\nUndefined Behavior (UB): This is a term for behavior that the C++ standard does not define at all, often resulting from code errors such as accessing out-of-bounds array elements or dereferencing null pointers. When a program exhibits undefined behavior, anything can happen, from seemingly normal operation to crashes or corrupt data.\nThe reasons behind undefined behavior’s existence? In essence, undefined behavior (UB) allows for high-performance, system-specific optimizations and maintains the language’s practicality and legacy support, at the cost of shifting the responsibility for avoiding it onto the programmer.\nThe concept of undefined behavior was not introduced by C++. It was already there in C.\nFor example, if you allocate an array in C, the data is unspecified. In Java (a language does not have UB), all bytes must be initialized to 0 (or some other specified value). This means the runtime must pass over the array (an O(n) operation), while C can perform the allocation in an instant. So C will always be faster for such operations.\nIf the code using the array is going to populate it anyway before reading, this is basically wasted effort for Java. But in the case where the code read first, you get predictable results in Java but unpredictable results in C.\nFor example, when compiling a loop that could theoretically overflow an integer:\nvoid copy_array(int* dst, const int* src, size_t size) { for (size_t i = 0; i \u003c size; ++i) { dst[i] = src[i]; } } The compiler can assume i will never overflow (as that would be undefined behavior), hence it can optimize without inserting overflow checks, resulting in faster loop execution.\nHow to avoid undefined behavior? Using try-catch blocks will not going to work, UB is not about exceptions handled in the wrong way.\nSo what can you do against undefined behaviour?\nTurn on whatever warnings you can (-Wall, -Wextra, -Wpedantic) and treat them as errors. Use a sanitizer, both g++ and clang offer some. Follow coding best practices and naming guidelines. Understand the concepts behind the language. Practice contractual programming (e.g., use and read document of the standard library) Share the knowledge What is iterator invalidation? Iterator invalidation refers to the loss of validity of an iterator due to certain modifications in the data structure it points to. In C++, iterators are often used to traverse containers like vectors, lists, maps, etc. If the container is modified (elements added, removed, or reallocated), existing iterators may no longer point to the correct elements or may point to memory that is no longer part of the container. Using invalidated iterators can lead to undefined behavior.\nRefer to this table to have a full list of when a container is invalidated.\n","wordCount":"804","inLanguage":"en","datePublished":"2023-12-02T18:12:37+08:00","dateModified":"2023-12-02T18:12:37+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-12-02-observable-behaviors/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Observable Behaviors</h1><div class=post-meta><span title='2023-12-02 18:12:37 +0800 CST'>December 2, 2023</span>&nbsp;·&nbsp;804 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#what-is-observable-behavior--related-issues>What is Observable Behavior & Related Issues</a></li><li><a href=#the-reasons-behind-undefined-behaviors-existence>The reasons behind undefined behavior’s existence?</a></li><li><a href=#how-to-avoid-undefined-behavior>How to avoid undefined behavior?</a></li><li><a href=#what-is-iterator-invalidation>What is iterator invalidation?</a></li></ul></nav></div></details></div><div class=post-content><h2 id=what-is-observable-behavior--related-issues>What is Observable Behavior & Related Issues<a hidden class=anchor aria-hidden=true href=#what-is-observable-behavior--related-issues>#</a></h2><p>The term observable behavior, according to the standard, means the following:</p><p>— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.</p><p>— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</p><p>— The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.</p><p>The “as-if rule” is strongly related, in short, any code transformation is allowed that does not change the observable behavior of the program.</p><p>The C++ standard precisely defines the observable behavior of every C++ program that does not fall into one of the following classes:</p><ul><li>ill-formed</li><li>ill-formed, no diagnostic required</li><li>implementation-defined behaviour</li><li>unspecified behaviour</li><li>undefined behaviour</li></ul><p><strong>Ill-Formed</strong>: The program has syntax errors and/or diagnosable semantic errors. The compiler will tell you about them. The violated rules are written in the standard with either shall, shall not or ill-formed.</p><p><strong>Ill-Formed, No Diagnostic Required (IFNDR)</strong>: There will be no compiler errors. The program doesn’t have syntactic errors, only semantic ones, but in general, they are not diagnosable by the compiler. These semantic errors are either detectable at link time, or if the program is executed, it results in undefined behavior.</p><p><strong>Implementation-Defined Behavior</strong>: This is behavior that the C++ standard does not define explicitly, leaving it up to the compiler or the runtime environment to decide how to implement it. The compiler documentation typically <strong>documents</strong> how it handles these situations. Examples include the size of an <strong><code>int</code></strong> or the rounding behavior of floating-point types.</p><p><strong>Unspecified Behavior</strong>: This refers to behavior that the standard allows to vary between different implementations, but unlike implementation-defined behavior, the compiler is <em><strong>not</strong> required to document</em> how it chooses to act. For instance, the order in which function arguments are evaluated is unspecified.</p><p><strong>Undefined Behavior (UB)</strong>: This is a term for behavior that the C++ standard does not define at all, often resulting from code errors such as accessing out-of-bounds array elements or dereferencing null pointers. When a program exhibits undefined behavior, anything can happen, from seemingly normal operation to crashes or corrupt data.</p><h2 id=the-reasons-behind-undefined-behaviors-existence>The reasons behind undefined behavior’s existence?<a hidden class=anchor aria-hidden=true href=#the-reasons-behind-undefined-behaviors-existence>#</a></h2><p>In essence, undefined behavior (UB) allows for high-performance, system-specific optimizations and maintains the language&rsquo;s practicality and legacy support, at the cost of shifting the responsibility for avoiding it onto the programmer.</p><p>The concept of undefined behavior was not introduced by C++. It was already there in C.</p><p><strong>For example</strong>, if you allocate an array in C, the data is unspecified. In Java (a language does not have UB), all bytes must be initialized to <code>0</code> (or some other specified value). This means the runtime must pass over the array (an <code>O(n)</code> operation), while C can perform the allocation in an instant. So C will always be faster for such operations.</p><p>If the code using the array is going to populate it anyway before reading, this is basically wasted effort for Java. But in the case where the code read first, you get predictable results in Java but unpredictable results in C.</p><p><strong>For example</strong>, when compiling a loop that could theoretically overflow an integer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=k>void</span> <span class=nx>copy_array</span><span class=p>(</span><span class=kr>int</span><span class=o>*</span> <span class=nx>dst</span><span class=p>,</span> <span class=kr>const</span> <span class=kr>int</span><span class=o>*</span> <span class=nx>src</span><span class=p>,</span> <span class=nx>size_t</span> <span class=nx>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=nx>size_t</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>size</span><span class=p>;</span> <span class=o>++</span><span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dst</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>=</span> <span class=nx>src</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The compiler can assume <code>i</code> will never overflow (as that would be undefined behavior), hence it can optimize without inserting overflow checks, resulting in faster loop execution.</p><h2 id=how-to-avoid-undefined-behavior>How to avoid undefined behavior?<a hidden class=anchor aria-hidden=true href=#how-to-avoid-undefined-behavior>#</a></h2><p>Using <code>try-catch</code> blocks will <strong>not</strong> going to work, UB is not about exceptions handled in the wrong way.</p><p><em>So what can you do against undefined behaviour?</em></p><ol><li>Turn on whatever warnings you can (-Wall, -Wextra, -Wpedantic) and treat them as errors.</li><li>Use a sanitizer, both g++ and clang offer some.</li><li>Follow coding best practices and naming guidelines.</li><li>Understand the concepts behind the language.</li><li>Practice contractual programming (e.g., use and read document of the standard library)</li><li>Share the knowledge</li></ol><h2 id=what-is-iterator-invalidation>What is iterator invalidation?<a hidden class=anchor aria-hidden=true href=#what-is-iterator-invalidation>#</a></h2><p><em>Iterator invalidation</em> refers to the loss of validity of an iterator due to certain modifications in the data structure it points to. In C++, iterators are often used to traverse containers like vectors, lists, maps, etc. If the container is modified (elements added, removed, or reallocated), existing iterators may no longer point to the correct elements or may point to memory that is no longer part of the container. Using invalidated iterators can lead to <strong>undefined behavior</strong>.</p><p>Refer to this <a href=https://en.cppreference.com/w/cpp/container#Iterator_invalidation>table</a> to have a full list of when a container is invalidated.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>