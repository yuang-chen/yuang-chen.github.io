<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SIMD is Pain | Yac's Log</title><meta name=keywords content="C++,SIMD"><meta name=description content="Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.
Indeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:
a single line of normal c++ code could be easily inflated to a dozen lines of code."><meta name=author content="Yac"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-04-25-simd-pain-intro/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="SIMD is Pain"><meta property="og:description" content="Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.
Indeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:
a single line of normal c++ code could be easily inflated to a dozen lines of code."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-04-25-simd-pain-intro/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-25T20:59:39+08:00"><meta property="article:modified_time" content="2023-04-25T20:59:39+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="SIMD is Pain"><meta name=twitter:description content="Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.
Indeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:
a single line of normal c++ code could be easily inflated to a dozen lines of code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SIMD is Pain","item":"https://yuang-chen.github.io/posts/2023-04-25-simd-pain-intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SIMD is Pain","name":"SIMD is Pain","description":"Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.\nIndeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:\na single line of normal c++ code could be easily inflated to a dozen lines of code.","keywords":["C++","SIMD"],"articleBody":"Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.\nIndeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:\na single line of normal c++ code could be easily inflated to a dozen lines of code. when the code comes with data dependency across loop iterations, the SIMD would hit right at my front head and give me massive headache (for debugging). the usage of SIMD require low-level C coding SIMD intrinsics are often not compatible across different platforms, and even different CPU models. SIMD intrinsics are available in ARM, Intel, AMD and Nvidia chips, but GPU/CUDA opens another genre of SIMD programming paradigm so I will not discuss here. AMD, for the x86 arch, offers the same intrinsic set as Intel does. Thus, only the intrinsics of ARM and Intel are really concerned.\nNotation Before going any further, I would like firstly clarify the terms of “vector” used in this blog, which unfortunately can be used to name two distinct matters.\nvector in C++, is a container with variable size holding dynamically allocated data in heap. vector in SIMD, is a type specifying the data stored in registers, with fixed sizes such as 128, 256, 512 bits. In following context, vector refers to as the container, and vec denotes the data in register.\nIntel Intrinsic Let’s talk about the Intel firstly, the (aging) boss of CPU.\nIntel provides a number of intrinsic sets to us, such as SSE, AVX2, …, AVX512. I only use AVX512 because it is the newest and widest set.\nnew means that AVX512 has something other sets do not have, for instance, the scatter and gather operations. The two counterparts are very useful, which is further discussed in another log.\nwide means AVX512 has 512-bit width vec. It is not obvious to see from the name at all.\nARM Intrinsics The computing capacity of ARM chip is weaker than that of Intel’s chip – I derive this personal and irresponsible conclusion based on the fact that the SIMD width of ARM is merely 128 bits and sometimes is even 64 bits. Why so short? I guess ARM prefers to 8-bit or 16-bit data type, sacrificing a little precision for efficiency, which makes the shorter vec more reasonable.\nAnother shortcoming of ARM intrinsics is the lack of masked operations. It happens all the time when the input data cannot be exactly fitted in the SIMD vec, or I just need a portion of data. The mask in Intel intrinsics allows us to easily extract/fill the imperfectly aligned vec. For ARM, sorry, we have to find alternative solutions, as described in this [log]\n","wordCount":"477","inLanguage":"en","datePublished":"2023-04-25T20:59:39+08:00","dateModified":"2023-04-25T20:59:39+08:00","author":{"@type":"Person","name":"Yac"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-04-25-simd-pain-intro/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SIMD is Pain</h1><div class=post-meta><span title='2023-04-25 20:59:39 +0800 CST'>April 25, 2023</span>&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Yac</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#notation>Notation</a></li><li><a href=#intel-intrinsic>Intel Intrinsic</a></li><li><a href=#arm-intrinsics>ARM Intrinsics</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Writing code with SIMD for vectorization is painful. It deserves a blog series to record all sorts of pains I have encountered and (partially) overcome.</p><p>Indeed, once the pain of coding and debugging is finished, the program is lightning-faster. Nonetheless, I am here to complain instead of praising. Let me state why writing SIMD code is causing me emotional damage:</p><ul><li>a single line of normal c++ code could be easily inflated to a dozen lines of code.</li><li>when the code comes with data dependency across loop iterations, the SIMD would hit right at my front head and give me massive headache (for debugging).</li><li>the usage of SIMD require low-level C coding</li><li>SIMD intrinsics are often not compatible across different platforms, and even different CPU models.</li></ul><p>SIMD intrinsics are available in ARM, Intel, AMD and Nvidia chips, but GPU/CUDA opens another genre of SIMD programming paradigm so I will not discuss here. AMD, for the x86 arch, offers the same intrinsic set as Intel does. Thus, only the intrinsics of ARM and Intel are really concerned.</p><h3 id=notation>Notation<a hidden class=anchor aria-hidden=true href=#notation>#</a></h3><p>Before going any further, I would like firstly clarify the terms of &ldquo;vector&rdquo; used in this blog, which unfortunately can be used to name two distinct matters.</p><ul><li><em>vector</em> in <code>C++</code>, is a <strong>container</strong> with variable size holding dynamically allocated data in heap.</li><li><em>vector</em> in <code>SIMD</code>, is a <strong>type</strong> specifying the data stored in registers, with fixed sizes such as 128, 256, 512 bits.</li></ul><p>In following context, <code>vector</code> refers to as the container, and <code>vec</code> denotes the data in register.</p><h3 id=intel-intrinsic>Intel Intrinsic<a hidden class=anchor aria-hidden=true href=#intel-intrinsic>#</a></h3><p>Let&rsquo;s talk about the Intel firstly, the (aging) boss of CPU.</p><p>Intel provides a number of intrinsic sets to us, such as SSE, AVX2, &mldr;, AVX512. I only use AVX512 because it is the <em><strong>newest</strong></em> and <em><strong>widest</strong></em> set.</p><p><em><strong>new</strong></em> means that AVX512 has something other sets do not have, for instance, the <code>scatter</code> and <code>gather</code> operations. The two counterparts are very useful, which is further discussed in another <a href=https://yuang-chen.github.io/posts/2023-04-27-gather-simd/>log</a>.</p><p><em><strong>wide</strong></em> means AVX512 has 512-bit width vec. It is not obvious to see from the name at all.</p><h3 id=arm-intrinsics>ARM Intrinsics<a hidden class=anchor aria-hidden=true href=#arm-intrinsics>#</a></h3><p>The computing capacity of ARM chip is weaker than that of Intel&rsquo;s chip &ndash; I derive this personal and irresponsible conclusion based on the fact that the SIMD width of ARM is merely 128 bits and sometimes is even 64 bits. Why so short? I guess ARM prefers to 8-bit or 16-bit data type, sacrificing a little precision for efficiency, which makes the shorter vec more reasonable.</p><p>Another shortcoming of ARM intrinsics is the lack of <em>masked</em> operations. It happens all the time when the input data cannot be exactly fitted in the SIMD vec, or I just need a portion of data. The <code>mask</code> in Intel intrinsics allows us to easily extract/fill the imperfectly aligned vec. For ARM, sorry, we have to find alternative solutions, as described in this [log]</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li><li><a href=https://yuang-chen.github.io/tags/simd/>SIMD</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>