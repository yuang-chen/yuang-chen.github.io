<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Small String Optimization | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="The basic struct of string consists of three members:
struct string { char* mPtr; // dynamically allocated memory size_t mSize; // the length of the string size_t mCapacity; // the size of allocated memory }; Allocating memory for small strings (e.g., empty string with a null \0 character) is wasteful. Hence, to avoid this waste, most implementations of string structs apply Small String Optimization (SSO), which stores small strings directly within the string object on the stack, rather than allocating memory dynamically on the heap."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2024-12-31-small-string-optimization/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Small String Optimization"><meta property="og:description" content="The basic struct of string consists of three members:
struct string { char* mPtr; // dynamically allocated memory size_t mSize; // the length of the string size_t mCapacity; // the size of allocated memory }; Allocating memory for small strings (e.g., empty string with a null \0 character) is wasteful. Hence, to avoid this waste, most implementations of string structs apply Small String Optimization (SSO), which stores small strings directly within the string object on the stack, rather than allocating memory dynamically on the heap."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2024-12-31-small-string-optimization/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-31T08:29:11+08:00"><meta property="article:modified_time" content="2024-12-31T08:29:11+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Small String Optimization"><meta name=twitter:description content="The basic struct of string consists of three members:
struct string { char* mPtr; // dynamically allocated memory size_t mSize; // the length of the string size_t mCapacity; // the size of allocated memory }; Allocating memory for small strings (e.g., empty string with a null \0 character) is wasteful. Hence, to avoid this waste, most implementations of string structs apply Small String Optimization (SSO), which stores small strings directly within the string object on the stack, rather than allocating memory dynamically on the heap."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Small String Optimization","item":"https://yuang-chen.github.io/posts/2024-12-31-small-string-optimization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Small String Optimization","name":"Small String Optimization","description":"The basic struct of string consists of three members:\nstruct string { char* mPtr; // dynamically allocated memory size_t mSize; // the length of the string size_t mCapacity; // the size of allocated memory }; Allocating memory for small strings (e.g., empty string with a null \\0 character) is wasteful. Hence, to avoid this waste, most implementations of string structs apply Small String Optimization (SSO), which stores small strings directly within the string object on the stack, rather than allocating memory dynamically on the heap.","keywords":["C++"],"articleBody":"The basic struct of string consists of three members:\nstruct string { char* mPtr; // dynamically allocated memory size_t mSize; // the length of the string size_t mCapacity; // the size of allocated memory }; Allocating memory for small strings (e.g., empty string with a null \\0 character) is wasteful. Hence, to avoid this waste, most implementations of string structs apply Small String Optimization (SSO), which stores small strings directly within the string object on the stack, rather than allocating memory dynamically on the heap. I found this trick is rather interesting, as it showcases how different C++ compilers and tied standard libraries implement the same concept in different ways.\nThere are four main implementations of SSO from GCC, MSVC, Clang and Facebook, plus one from (github)[https://github.com/elliotgoodrich/SSO-23/tree/master]. Let’s take a look at them one by one.\nlibstdc++ from GCC The GCC_String class is a minimal implementation of a string structure with Small String Optimization (SSO), following GCC. Notice that the actual GCC implementation costs 32 bytes, with mBuf occupying 15 bytes, which is larger than the 8-byte mCapacity (8 bytes) in the union.\nData Members: char* mPtr: Points to the memory holding the string data. size_t mSize: Stores the size (length) of the string. union { size_t mCapacity; char mBuf[8]; }: For small strings, mBuf acts as an internal buffer to store the string directly (SSO). For larger strings, mCapacity holds the capacity of the dynamically allocated memory. SSO Logic: If the string length is small (less than 7 characters), the string data is stored in mBuf. For longer strings, memory is dynamically allocated on the heap, and mPtr points to it. GCC uses a consistent pointer mPtr either points to the internal stack buffer or the heap memory. #include #include #include #include struct GCC_String { char* mPtr; size_t mSize{}; union { size_t mCapacity; char mBuf[8]; }; static_assert((sizeof(mBuf) + sizeof(mPtr) + sizeof(mSize)) == 24); // The mPtr{mBuf} sets the mPtr to point to the internal buffer mBuf, // indicating that this string instance will use SSO. // mBuf{} zero-initializes mBuf, ensuring all characters in the buffer // are set to '\\0' by default. constexpr GCC_String(): mPtr{mBuf}, mBuf{} {} constexpr GCC_String(const char* data) :GCC_String(data, data? std::char_traits\u003cchar\u003e::length(data): 0){} constexpr GCC_String(const char* data, size_t len) : mPtr{fits_into_small_string(len)? mBuf: new char[len]}, mSize{len}, mBuf{} { if(!is_small_string()) { mCapacity = len; } std::copy_n(data, len, mPtr); } constexpr const char* data() const { return mPtr; } constexpr bool fits_into_small_string(size_t len) { return len \u003c small_string_capacity(); } constexpr bool is_small_string() const { return mBuf == mPtr; } constexpr size_t small_string_capacity() const { return sizeof(mBuf) - 1; // -1 for '\\0' } constexpr size_t size() const { return mSize; } constexpr size_t capacity() const { return is_small_string()? small_string_capacity(): mCapacity; } }; int main () { std::cout \u003c\u003c \"gcc_string struct size: \" \u003c\u003c sizeof(GCC_String) \u003c\u003c std::endl; GCC_String small(\"short\"); GCC_String large(\"this is a long string\"); GCC_String empty(nullptr); std::cout \u003c\u003c \"small: struct size: \" \u003c\u003c sizeof(small) \u003c\u003c \" capacity: \" \u003c\u003c small.capacity() \u003c\u003c \" size: \" \u003c\u003c small.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", small.data()); std::cout \u003c\u003c \"large: struct size: \" \u003c\u003c sizeof(large) \u003c\u003c \" capacity: \" \u003c\u003c large.capacity() \u003c\u003c \" size: \" \u003c\u003c large.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", large.data()); return 0; } MS STL from MSVC The implementation of MSVC is similar to GCC, but it uses a union differently:\nData Members: A union for either: A pointer to dynamically allocated memory. A static buffer (char mBuf[8]). size_t mSize: Current size. size_t mCapacity: Capacity indicator. SSO Logic: If the string length is small (less than 7 characters), the string data is stored in mBuf. For longer strings, memory is dynamically allocated on the heap, and mPtr points to it. MSVC uses a union to switch between the buffer and the pointer, requiring a check each time to determine which one to use. #include #include #include struct MS_String { union { char* mPtr; char mBuf[8]; }; size_t mSize{}; size_t mCapacity; static_assert((sizeof(mBuf) + sizeof(mPtr) + sizeof(mSize)) == 24); constexpr MS_String(): mBuf{} {} constexpr MS_String(const char* data) :MS_String(data, data? std::char_traits\u003cchar\u003e::length(data): 0){} constexpr MS_String(const char* data, size_t len) : mBuf{}, mSize{len}, mCapacity{fits_into_small_string(len)? small_string_capacity(): len} { if(!is_small_string()) { mPtr = new char[len]; std::copy_n(data, len, mPtr); } else { std::copy_n(data, len, mBuf); } } constexpr const char* data() const { return is_small_string()? mBuf: mPtr; } constexpr bool fits_into_small_string(size_t len) { return len \u003c small_string_capacity(); } constexpr bool is_small_string() const { return mCapacity \u003c= small_string_capacity(); } constexpr size_t small_string_capacity() const { return sizeof(mBuf) - 1; // -1 for '\\0' } constexpr size_t size() const { return mSize; } constexpr size_t capacity() const { return mCapacity; } }; int main () { std::cout \u003c\u003c \"MS_string struct size: \" \u003c\u003c sizeof(MS_String) \u003c\u003c std::endl; MS_String small(\"short\"); MS_String large(\"this is a long string\"); MS_String empty(nullptr); std::cout \u003c\u003c \"small: struct size: \" \u003c\u003c sizeof(small) \u003c\u003c \" capacity: \" \u003c\u003c small.capacity() \u003c\u003c \" size: \" \u003c\u003c small.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", small.data()); std::cout \u003c\u003c \"large: struct size: \" \u003c\u003c sizeof(large) \u003c\u003c \" capacity: \" \u003c\u003c large.capacity() \u003c\u003c \" size: \" \u003c\u003c large.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", large.data()); return 0; } libstdc++ from Clang The implementation of Clang uses a single bit to switch between large and small strings. With a more compact layout, it provides a larger buffer (16 bytes) than GCC and MSVC (8 bytes).\nData Field: Union of two structs: Large_String struct (24 bytes total):\nA 1-bit flag indicating if it’s a large string 63 bits for capacity Size field (8 bytes) Pointer to data (8 bytes) Small_String struct (24 bytes total):\nA 1-bit flag indicating if it’s a large string 7 bits for size 7 bytes padding 16 bytes inline buffer for string data The SSO logic:\nUses just 1 bit to distinguish between small/large strings Provides 16 bytes buffer for small strings For small strings, stores data directly in the mData buffer For large strings, allocates memory and stores pointer in mData Both structs are exactly 24 bytes, allowing them to be stored in a union #include #include #include struct Clang_String { struct Large_String { size_t is_large : 1; size_t mCapacity : 63; size_t mSize; char* mData; }; struct Small_String { uint8_t is_large : 1; uint8_t mSize : 7; uint8_t mPaddingBytes[7]; // sizeof(size_t) - sizeof(uint8_t) char mBuf[16]; // sizeof(Large_String) - sizeof(size_t) }; union { Large_String large; Small_String small; } packed; static_assert((sizeof(Large_String) == 24 \u0026\u0026 sizeof(Large_String) == sizeof(Small_String))); constexpr Clang_String(): packed{} {} constexpr Clang_String(const char* data) :Clang_String(data, data? std::char_traits\u003cchar\u003e::length(data): 0){} constexpr Clang_String(const char* data, size_t len) { if(fits_into_small_string(len)) { packed.small.mSize = len; std::copy_n(data, len, packed.small.mBuf); } else { packed.large.is_large = true; packed.large.mSize = len; packed.large.mCapacity = len; packed.large.mData = new char[len]; std::copy_n(data, len, packed.large.mData); } } constexpr const char* data() const { return is_small_string()? packed.small.mBuf: packed.large.mData; } constexpr bool fits_into_small_string(size_t len) { return len \u003c small_string_capacity(); } constexpr bool is_small_string() const { return !packed.large.is_large; } constexpr size_t small_string_capacity() const { return sizeof(packed.small.mBuf) - 1; } constexpr size_t size() const { return is_small_string()? packed.small.mSize: packed.large.mSize; } constexpr size_t capacity() const { return is_small_string()? small_string_capacity(): packed.large.mCapacity; } }; int main () { auto str = Clang_String{}; std::cout \u003c\u003c \"Clang_String struct size: \" \u003c\u003c sizeof(Clang_String) \u003c\u003c std::endl; Clang_String small(\"short\"); Clang_String large(\"this is a long string\"); Clang_String empty(nullptr); std::cout \u003c\u003c \"small: struct size: \" \u003c\u003c sizeof(small) \u003c\u003c \", capacity: \" \u003c\u003c small.capacity() \u003c\u003c \", size: \" \u003c\u003c small.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", small.data()); std::cout \u003c\u003c \"large: struct size: \" \u003c\u003c sizeof(large) \u003c\u003c \", capacity: \" \u003c\u003c large.capacity() \u003c\u003c \", size: \" \u003c\u003c large.size() \u003c\u003c \" -- \"; printf(\"%s\\n\", large.data()); return 0; } ","wordCount":"1250","inLanguage":"en","datePublished":"2024-12-31T08:29:11+08:00","dateModified":"2024-12-31T08:29:11+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2024-12-31-small-string-optimization/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Small String Optimization</h1><div class=post-meta><span title='2024-12-31 08:29:11 +0800 CST'>December 31, 2024</span>&nbsp;·&nbsp;1250 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p>The basic struct of string consists of three members:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>mPtr</span><span class=p>;</span>         <span class=c1>// dynamically allocated memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>mSize</span><span class=p>;</span>       <span class=c1>// the length of the string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>mCapacity</span><span class=p>;</span>   <span class=c1>// the size of allocated memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>Allocating memory for small strings (e.g., empty string with a null <code>\0</code> character) is wasteful. Hence, to avoid this waste, most implementations of <code>string</code> structs apply Small String Optimization (SSO), which stores <strong>small strings</strong> directly within the string object on the <code>stack</code>, rather than allocating memory dynamically on the <code>heap</code>. I found this trick is rather interesting, as it showcases how different C++ compilers and tied standard libraries implement the same concept in different ways.</p><p>There are four main implementations of SSO from GCC, MSVC, Clang and Facebook, plus one from (github)[https://github.com/elliotgoodrich/SSO-23/tree/master]. Let&rsquo;s take a look at them one by one.</p><h2 id=libstdc-from-gcc><code>libstdc++</code> from GCC<a hidden class=anchor aria-hidden=true href=#libstdc-from-gcc>#</a></h2><p>The <code>GCC_String</code> class is a minimal implementation of a string structure with Small String Optimization (SSO), following GCC. Notice that the actual GCC implementation costs 32 bytes, with <code>mBuf</code> occupying 15 bytes, which is larger than the 8-byte <code>mCapacity</code> (8 bytes) in the <code>union</code>.</p><ol><li>Data Members:<ul><li><code>char* mPtr</code>: Points to the memory holding the string data.</li><li><code>size_t mSize</code>: Stores the size (length) of the string.</li><li><code>union { size_t mCapacity; char mBuf[8]; }</code>:<ul><li>For small strings, <code>mBuf</code> acts as an internal buffer to store the string directly (SSO).</li><li>For larger strings, <code>mCapacity</code> holds the capacity of the dynamically allocated memory.</li></ul></li></ul></li><li>SSO Logic:<ul><li>If the string length is small (less than 7 characters), the string data is stored in <code>mBuf</code>.</li><li>For longer strings, memory is dynamically allocated on the heap, and <code>mPtr</code> points to it.</li><li>GCC uses a consistent pointer <code>mPtr</code> either points to the internal stack buffer or the heap memory.</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstddef&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>GCC_String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>mPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>mSize</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>mCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>mBuf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>static_assert</span><span class=p>((</span><span class=k>sizeof</span><span class=p>(</span><span class=n>mBuf</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mPtr</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mSize</span><span class=p>))</span> <span class=o>==</span> <span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The mPtr{mBuf} sets the mPtr to point to the internal buffer mBuf,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// indicating that this string instance will use SSO.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// mBuf{} zero-initializes mBuf, ensuring all characters in the buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// are set to &#39;\0&#39; by default.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>constexpr</span> <span class=nf>GCC_String</span><span class=p>()</span><span class=o>:</span> <span class=n>mPtr</span><span class=p>{</span><span class=n>mBuf</span><span class=p>},</span> <span class=n>mBuf</span><span class=p>{}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>GCC_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span><span class=n>GCC_String</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>data</span><span class=o>?</span> <span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;::</span><span class=n>length</span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=o>:</span> <span class=mi>0</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>GCC_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mPtr</span><span class=p>{</span><span class=n>fits_into_small_string</span><span class=p>(</span><span class=n>len</span><span class=p>)</span><span class=o>?</span> <span class=nl>mBuf</span><span class=p>:</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>len</span><span class=p>]},</span>
</span></span><span class=line><span class=cl>         <span class=n>mSize</span><span class=p>{</span><span class=n>len</span><span class=p>},</span>
</span></span><span class=line><span class=cl>         <span class=n>mBuf</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>is_small_string</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mCapacity</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>mPtr</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>data</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>fits_into_small_string</span><span class=p>(</span><span class=n>size_t</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=n>small_string_capacity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>is_small_string</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mBuf</span> <span class=o>==</span> <span class=n>mPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>small_string_capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mBuf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// -1 for &#39;\0&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is_small_string</span><span class=p>()</span><span class=o>?</span> <span class=n>small_string_capacity</span><span class=p>()</span><span class=o>:</span> <span class=n>mCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;gcc_string struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>GCC_String</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>GCC_String</span> <span class=n>small</span><span class=p>(</span><span class=s>&#34;short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>GCC_String</span> <span class=n>large</span><span class=p>(</span><span class=s>&#34;this is a long string&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>GCC_String</span> <span class=n>empty</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;small: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>small</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>small</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;large: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>large</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>large</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ms-stl-from-msvc><code>MS STL</code> from MSVC<a hidden class=anchor aria-hidden=true href=#ms-stl-from-msvc>#</a></h2><p>The implementation of MSVC is similar to GCC, but it uses a <code>union</code> differently:</p><ol><li>Data Members:<ul><li>A union for either:<ul><li>A pointer to dynamically allocated memory.</li><li>A static buffer (char <code>mBuf[8]</code>).</li></ul></li><li><code>size_t mSize</code>: Current size.</li><li><code>size_t mCapacity</code>: Capacity indicator.</li></ul></li><li>SSO Logic:<ul><li>If the string length is small (less than 7 characters), the string data is stored in <code>mBuf</code>.</li><li>For longer strings, memory is dynamically allocated on the heap, and <code>mPtr</code> points to it.</li><li>MSVC uses a union to switch between the buffer and the pointer, requiring a check each time to determine which one to use.</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstddef&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MS_String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span><span class=o>*</span> <span class=n>mPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>mBuf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>mSize</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>mCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static_assert</span><span class=p>((</span><span class=k>sizeof</span><span class=p>(</span><span class=n>mBuf</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mPtr</span><span class=p>)</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mSize</span><span class=p>))</span> <span class=o>==</span> <span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>MS_String</span><span class=p>()</span><span class=o>:</span> <span class=n>mBuf</span><span class=p>{}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>MS_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span><span class=n>MS_String</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>data</span><span class=o>?</span> <span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;::</span><span class=n>length</span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=o>:</span> <span class=mi>0</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>MS_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mBuf</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>         <span class=n>mSize</span><span class=p>{</span><span class=n>len</span><span class=p>},</span> 
</span></span><span class=line><span class=cl>         <span class=n>mCapacity</span><span class=p>{</span><span class=n>fits_into_small_string</span><span class=p>(</span><span class=n>len</span><span class=p>)</span><span class=o>?</span> <span class=n>small_string_capacity</span><span class=p>()</span><span class=o>:</span> <span class=n>len</span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>is_small_string</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mPtr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>len</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>mPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> 
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>mBuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>data</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is_small_string</span><span class=p>()</span><span class=o>?</span> <span class=nl>mBuf</span><span class=p>:</span> <span class=n>mPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>fits_into_small_string</span><span class=p>(</span><span class=n>size_t</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=n>small_string_capacity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>is_small_string</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mCapacity</span> <span class=o>&lt;=</span> <span class=n>small_string_capacity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>small_string_capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mBuf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// -1 for &#39;\0&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;MS_string struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>MS_String</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>MS_String</span> <span class=n>small</span><span class=p>(</span><span class=s>&#34;short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MS_String</span> <span class=n>large</span><span class=p>(</span><span class=s>&#34;this is a long string&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>MS_String</span> <span class=n>empty</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;small: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>small</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>small</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;large: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>large</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>large</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=libstdc-from-clang><code>libstdc++</code> from Clang<a hidden class=anchor aria-hidden=true href=#libstdc-from-clang>#</a></h3><p>The implementation of Clang uses a single bit to switch between large and small strings. With a more compact layout, it provides a larger buffer (16 bytes) than GCC and MSVC (8 bytes).</p><ol><li>Data Field: Union of two structs:<ul><li><p><code>Large_String</code> struct (24 bytes total):</p><ul><li>A 1-bit flag indicating if it&rsquo;s a large string</li><li>63 bits for capacity</li><li>Size field (8 bytes)</li><li>Pointer to data (8 bytes)</li></ul></li><li><p><code>Small_String</code> struct (24 bytes total):</p><ul><li>A 1-bit flag indicating if it&rsquo;s a large string</li><li>7 bits for size</li><li>7 bytes padding</li><li>16 bytes inline buffer for string data</li></ul></li></ul></li></ol><p>The SSO logic:</p><ul><li>Uses just 1 bit to distinguish between small/large strings</li><li>Provides 16 bytes buffer for small strings</li><li>For small strings, stores data directly in the <code>mData</code> buffer</li><li>For large strings, allocates memory and stores pointer in <code>mData</code></li><li>Both structs are exactly 24 bytes, allowing them to be stored in a union</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstddef&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Clang_String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>Large_String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=nl>is_large</span>  <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=nl>mCapacity</span> <span class=p>:</span> <span class=mi>63</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>mSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span><span class=o>*</span>  <span class=n>mData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>Small_String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=nl>is_large</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=nl>mSize</span>    <span class=p>:</span> <span class=mi>7</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>mPaddingBytes</span><span class=p>[</span><span class=mi>7</span><span class=p>];</span> <span class=c1>// sizeof(size_t) - sizeof(uint8_t)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>char</span>    <span class=n>mBuf</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span> <span class=c1>// sizeof(Large_String) - sizeof(size_t)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Large_String</span> <span class=n>large</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Small_String</span> <span class=n>small</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>packed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static_assert</span><span class=p>((</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Large_String</span><span class=p>)</span> <span class=o>==</span> <span class=mi>24</span> <span class=o>&amp;&amp;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Large_String</span><span class=p>)</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Small_String</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Clang_String</span><span class=p>()</span><span class=o>:</span> <span class=n>packed</span><span class=p>{}</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Clang_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span><span class=n>Clang_String</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>data</span><span class=o>?</span> <span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;::</span><span class=n>length</span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=o>:</span> <span class=mi>0</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Clang_String</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>fits_into_small_string</span><span class=p>(</span><span class=n>len</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>packed</span><span class=p>.</span><span class=n>small</span><span class=p>.</span><span class=n>mSize</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>packed</span><span class=p>.</span><span class=n>small</span><span class=p>.</span><span class=n>mBuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>is_large</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mSize</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mCapacity</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mData</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>len</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>data</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is_small_string</span><span class=p>()</span><span class=o>?</span> <span class=n>packed</span><span class=p>.</span><span class=n>small</span><span class=p>.</span><span class=nl>mBuf</span><span class=p>:</span> <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>fits_into_small_string</span><span class=p>(</span><span class=n>size_t</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>len</span> <span class=o>&lt;</span> <span class=n>small_string_capacity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=kt>bool</span> <span class=nf>is_small_string</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>!</span><span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>is_large</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>small_string_capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>packed</span><span class=p>.</span><span class=n>small</span><span class=p>.</span><span class=n>mBuf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is_small_string</span><span class=p>()</span><span class=o>?</span> <span class=n>packed</span><span class=p>.</span><span class=n>small</span><span class=p>.</span><span class=nl>mSize</span><span class=p>:</span> <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>is_small_string</span><span class=p>()</span><span class=o>?</span> <span class=n>small_string_capacity</span><span class=p>()</span><span class=o>:</span> <span class=n>packed</span><span class=p>.</span><span class=n>large</span><span class=p>.</span><span class=n>mCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>str</span> <span class=o>=</span> <span class=n>Clang_String</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Clang_String struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Clang_String</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Clang_String</span> <span class=n>small</span><span class=p>(</span><span class=s>&#34;short&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Clang_String</span> <span class=n>large</span><span class=p>(</span><span class=s>&#34;this is a long string&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Clang_String</span> <span class=n>empty</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;small: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>small</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;, capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;, size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>small</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>small</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;large: struct size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>large</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;, capacity: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;, size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>large</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34; -- &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>large</span><span class=p>.</span><span class=n>data</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>