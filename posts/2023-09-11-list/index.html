<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>List | Yac's Log</title><meta name=keywords content="STL"><meta name=description content="Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.
A valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-09-11-list/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="List"><meta property="og:description" content="Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.
A valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-09-11-list/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-11T16:33:34+08:00"><meta property="article:modified_time" content="2023-09-11T16:33:34+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="List"><meta name=twitter:description content="Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.
A valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"List","item":"https://yuang-chen.github.io/posts/2023-09-11-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"List","name":"List","description":"Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.\nA valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures.","keywords":["STL"],"articleBody":"Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.\nA valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures.\n// code example for(auto it = container.begin(); it != container.end(); ++it ) { container.push_back(new_element); // which might cause memory re-allocation } When elements are inserted or deleted in a list, it doesnâ€™t affect the memory addresses or links of the other elements. So, one can manipulate elements within a list without worrying about the iterators becoming invalidated (i.e., pointing to unexpected or erroneous locations in memory). Thus, it is safe for a list to run the code example.\nIn contrast, some other data structures, like vectors, set or unordered_set, might need to reallocate memory or rehash the elements when elements are added or removed, leading to potential iterator invalidation. Do not employ the above code to those containers!\nCode Basic implementations of list and forward_list:\n#include /********************/ /*Double linked list*/ /********************/ template \u003ctypename T\u003e class List { private: struct Node { T data_; Node* next_; Node* prev_; Node(T data, Node* next, Node* prev) : data_(data), next_(next), prev_(prev) {} }; Node* head_; Node* tail_; size_t size_; public: List() : head_(nullptr), tail_(nullptr), size_(0) {} ~List() { Node* curr = head_; while(curr != nullptr) { Node* next = curr-\u003enext_; delete curr; curr = next; } } void push_back(T value) { Node* new_node = new Node(value, nullptr, nullptr); if(tail_) { tail_-\u003enext_ = new_node; new_node-\u003eprev_ = tail_; tail_ = new_node; } else { head_ = new_node; tail_ = new_node; } size_++; } void push_front(T value) { Node* new_node = new Node(value, nullptr, nullptr); if(head_) { head_-\u003eprev_ = new_node; new_node-\u003enext_ = head_; head_ = new_node; } else { head_ = new_node; tail_ = new_node; } size_++; } void pop_back() { if(tail_) { Node* temp = tail_; tail_ = tail_-\u003eprev_; delete tail_; size_--; } } void pop_front() { if(head_) { Node* temp = head_; head_ = head_-\u003enext_; delete head_; size_--; } } T\u0026 back() { return tail_-\u003edata_; } T\u0026 front() { return head_-\u003edata_; } // the standard library use iterator to index the position void insert(size_t pos, T value) {} size_t size() const { return size_; } }; /********************/ /*Single linked list*/ /********************/ template \u003ctypename T\u003e class ForwardList { private: struct Node { T data_; Node* next_; Node(T data, Node* next) : data_(data), next_(next) {} }; Node* head_; size_t size_; public: ForwardList() : head_(nullptr), size_(0) {} ~ForwardList() { Node* curr = head_; while(curr != nullptr) { Node* next = curr-\u003enext_; delete curr; curr = next; } } // stl library uses iterator to index the position void insert_after(size_t pos, T value) { if(pos \u003e size_) { return; } Node* new_node = new Node(value, nullptr); Node* curr = head_; for(size_t i = 0; i \u003c pos - 1; i++) { curr = curr-\u003enext_; } Node* temp = curr-\u003enext_; curr-\u003enext_ = new_node; new_node-\u003enext_ = temp; size_++; } void push_front(T value) { Node* new_node = new Node(value, nullptr); if(head_) { new_node-\u003enext_ = head_; head_ = new_node; } else { head_ = new_node; } size_++; } void erase_after(size_t pos) { if(pos \u003e size_) { return; } Node* curr = head_; for(size_t i = 0; i \u003c pos - 1; i++) { curr = curr-\u003enext_; } Node* temp = curr-\u003enext_; curr-\u003enext_ = temp-\u003enext_; delete temp; } void pop_front() { if(head_) { Node* temp = head_; head_ = head_-\u003enext_; delete temp; size_--; } } T\u0026 front() { return head_-\u003edata_; } // the standard library use iterator to index the position void insert(size_t pos, T value) {} size_t size() const { return size_; } }; int main() { List\u003cint\u003e list; list.push_back(1); list.push_back(2); list.push_back(3); list.push_back(4); list.push_front(-1); list.push_front(-2); list.push_front(-3); list.push_front(-4); std::cout \u003c\u003c \"list size_: \" \u003c\u003c list.size() \u003c\u003c std::endl; std::cout \u003c\u003c \"list head_: \" \u003c\u003c list.front() \u003c\u003c std::endl; std::cout \u003c\u003c \"list tail_: \" \u003c\u003c list.back() \u003c\u003c std::endl; ForwardList\u003cint\u003e forward_list; forward_list.push_front(6); forward_list.push_front(3); forward_list.push_front(2); forward_list.push_front(1); forward_list.insert_after(3, 4); forward_list.insert_after(4, 5); while(forward_list.size() \u003e 0) { std::cout \u003c\u003c forward_list.front() \u003c\u003c std::endl; forward_list.pop_front(); } return 0; } Reference https://en.cppreference.com/w/cpp/container/list https://en.cppreference.com/w/cpp/container/forward_list\n","wordCount":"707","inLanguage":"en","datePublished":"2023-09-11T16:33:34+08:00","dateModified":"2023-09-11T16:33:34+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-09-11-list/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>List</h1><div class=post-meta><span title='2023-09-11 16:33:34 +0800 HKT'>September 11, 2023</span>&nbsp;Â·&nbsp;707 words&nbsp;Â·&nbsp;Me</div></header><div class=post-content><h2 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h2><p>STL indeed offers <code>std::list</code> and <code>std::forward_list</code>, which are essentially <strong>double-linked list</strong> and <strong>single-linked list</strong>, respectively. <code>std::list</code> provides operations like <code>push_back/front</code>, <code>pop_back/front</code> with a time complexity of O(1), and supports bidirectional iterators. On the other hand, <code>std::forward_list</code> only allows fronting operations with O(1) and <code>insert/erase_after</code> for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.</p><p>A valuable feature of lists is that they prohibit <code>iterator invalidation</code> compared to some other data structures.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// code example
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>container</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>container</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>container</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>new_element</span><span class=p>);</span> <span class=c1>// which might cause memory re-allocation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>When elements are inserted or deleted in a list, it doesn&rsquo;t affect the memory addresses or links of the other elements. So, one can manipulate elements within a list without worrying about the iterators becoming invalidated (i.e., pointing to unexpected or erroneous locations in memory). Thus, it is safe for a list to run the code example.</p><p>In contrast, some other data structures, like vectors, set or unordered_set, might need to reallocate memory or rehash the elements when elements are added or removed, leading to potential iterator invalidation. Do not employ the above code to those containers!</p><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p>Basic implementations of <code>list</code> and <code>forward_list</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/********************/</span>
</span></span><span class=line><span class=cl><span class=cm>/*Double linked list*/</span>
</span></span><span class=line><span class=cl><span class=cm>/********************/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>List</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span>     <span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>prev_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=p>(</span><span class=n>T</span> <span class=n>data</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span> <span class=n>prev</span><span class=p>)</span> <span class=o>:</span> <span class=n>data_</span><span class=p>(</span><span class=n>data</span><span class=p>),</span> <span class=n>next_</span><span class=p>(</span><span class=n>next</span><span class=p>),</span> <span class=n>prev_</span><span class=p>(</span><span class=n>prev</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span>  <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span>  <span class=n>tail_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=p>()</span> <span class=o>:</span> <span class=n>head_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>tail_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>List</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>curr</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>curr</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Node</span><span class=o>*</span> <span class=n>next</span> <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>curr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>curr</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>push_back</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>new_node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>tail_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>tail_</span><span class=o>-&gt;</span><span class=n>next_</span>    <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>new_node</span><span class=o>-&gt;</span><span class=n>prev_</span> <span class=o>=</span> <span class=n>tail_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>tail_</span>           <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span> <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>tail_</span> <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>push_front</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>new_node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>head_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span><span class=o>-&gt;</span><span class=n>prev_</span>    <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>new_node</span><span class=o>-&gt;</span><span class=n>next_</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span>           <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span> <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>tail_</span> <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>pop_back</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>tail_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Node</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>tail_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>tail_</span>      <span class=o>=</span> <span class=n>tail_</span><span class=o>-&gt;</span><span class=n>prev_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>tail_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>size_</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>pop_front</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>head_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Node</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span>      <span class=o>=</span> <span class=n>head_</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>size_</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>&amp;</span> <span class=n>back</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tail_</span><span class=o>-&gt;</span><span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>&amp;</span> <span class=n>front</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>head_</span><span class=o>-&gt;</span><span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the standard library use iterator to index the position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>size_t</span> <span class=n>pos</span><span class=p>,</span> <span class=n>T</span> <span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/********************/</span>
</span></span><span class=line><span class=cl><span class=cm>/*Single linked list*/</span>
</span></span><span class=line><span class=cl><span class=cm>/********************/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ForwardList</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span>     <span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=p>(</span><span class=n>T</span> <span class=n>data</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>)</span> <span class=o>:</span> <span class=n>data_</span><span class=p>(</span><span class=n>data</span><span class=p>),</span> <span class=n>next_</span><span class=p>(</span><span class=n>next</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>*</span>  <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardList</span><span class=p>()</span> <span class=o>:</span> <span class=n>head_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>ForwardList</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>curr</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>curr</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Node</span><span class=o>*</span> <span class=n>next</span> <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>curr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>curr</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// stl library uses iterator to index the position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert_after</span><span class=p>(</span><span class=n>size_t</span> <span class=n>pos</span><span class=p>,</span> <span class=n>T</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pos</span> <span class=o>&gt;</span> <span class=n>size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>new_node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>curr</span>     <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pos</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>curr</span> <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>temp</span>      <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span>     <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new_node</span><span class=o>-&gt;</span><span class=n>next_</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>push_front</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>new_node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>head_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>new_node</span><span class=o>-&gt;</span><span class=n>next_</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span>           <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span> <span class=o>=</span> <span class=n>new_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>erase_after</span><span class=p>(</span><span class=n>size_t</span> <span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pos</span> <span class=o>&gt;</span> <span class=n>size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>curr</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>pos</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>curr</span> <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=n>temp</span>  <span class=o>=</span> <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>curr</span><span class=o>-&gt;</span><span class=n>next_</span> <span class=o>=</span> <span class=n>temp</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>pop_front</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>head_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Node</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>head_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>head_</span>      <span class=o>=</span> <span class=n>head_</span><span class=o>-&gt;</span><span class=n>next_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>size_</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>&amp;</span> <span class=n>front</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>head_</span><span class=o>-&gt;</span><span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the standard library use iterator to index the position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>size_t</span> <span class=n>pos</span><span class=p>,</span> <span class=n>T</span> <span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=o>-</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=o>-</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;list size_: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;list head_: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>front</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;list tail_: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ForwardList</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>forward_list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>insert_after</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>forward_list</span><span class=p>.</span><span class=n>insert_after</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>forward_list</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>forward_list</span><span class=p>.</span><span class=n>front</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>forward_list</span><span class=p>.</span><span class=n>pop_front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=https://en.cppreference.com/w/cpp/container/list>https://en.cppreference.com/w/cpp/container/list</a>
<a href=https://en.cppreference.com/w/cpp/container/forward_list>https://en.cppreference.com/w/cpp/container/forward_list</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/stl/>STL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>