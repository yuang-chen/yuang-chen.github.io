<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STL Containers | Yac's Log</title><meta name=keywords content="STL"><meta name=description content="In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I&rsquo;ve been revisiting fundamental graph algorithms, I&rsquo;ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.
They are:"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-08-30-stl-containers/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="STL Containers"><meta property="og:description" content="In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I&rsquo;ve been revisiting fundamental graph algorithms, I&rsquo;ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.
They are:"><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-08-30-stl-containers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-30T14:13:22+08:00"><meta property="article:modified_time" content="2023-08-30T14:13:22+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="STL Containers"><meta name=twitter:description content="In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I&rsquo;ve been revisiting fundamental graph algorithms, I&rsquo;ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.
They are:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STL Containers","item":"https://yuang-chen.github.io/posts/2023-08-30-stl-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL Containers","name":"STL Containers","description":"In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I\u0026rsquo;ve been revisiting fundamental graph algorithms, I\u0026rsquo;ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.\nThey are:","keywords":["STL"],"articleBody":"In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I’ve been revisiting fundamental graph algorithms, I’ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.\nThey are:\nC++98: std::map, std::set, std::multimap, and std::multiset C++11: std::unordered_map, std::unordered_set, std::unordered_multimap, and std::unordered_multiset C++23: std::flat_map, std::flat_set, std::flat_multimap, and std::flat_multiset Sequence Containers Data structures which can be accessed sequentially.\nstd::array std::vector std::deque std::list std::forward_list Associative Containers Sorted data structures (i.e., balanced binary search tree) that can be quickly searched (O(log n) complexity).\nstd::set std::multiset std::map std::multimap Typically, an associate container consists a data type(s), a comparison function, and an allocator\ntemplate\u003ctypename Key, typename Value, typename Compare = std::less\u003ckey\u003e, typename Allocator = std::allocator\u003cstd::pair\u003cconst Key, Value\u003e\u003e\u003e Unordered Associative Containers Unsorted data structures (i.e., hashing bucket) that can be quickly searched (O(1) average, O(n) worst-case complexity).\nstd::unordered_set std::unordered_map std::unordered_multiset std::unordered_multimap Typically, an unordered associate container consists a data type(s), a hash function, an equal function and an allocator. The equal function indicates this type of containers does not provide support for comparison.\ntemplate\u003c typename Key, typename T, typename Hash = std::hash\u003cKey\u003e, typename KeyEqual = std::equal_to\u003cKey\u003e, typename Allocator = std::allocator\u003cstd::pair\u003cconst Key, T\u003e\u003e \u003e Container adaptors A different interface for sequential containers.\nstd::stack std::queue std::priority_queue std::flat_set (c++23) std::flat_map (c++23) std::flat_multiset (c++23) std::flat_multimap (c++23) The flat-ordered associative containers in C++23 have the same interface as their C++98 pendants. They adopt from sequence containers, e.g., std::vector by default.\nReference [1] Back to Basics: Standard Library Containers in Cpp - Rainer Grimm - CppCon 2022\n[2] C++23: Four new Associative Containers\n[3] Refresher on Containers, Algorithms and Performance in C++ - Vladimir Vishnevskii - CppCon 2022\n","wordCount":"310","inLanguage":"en","datePublished":"2023-08-30T14:13:22+08:00","dateModified":"2023-08-30T14:13:22+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-08-30-stl-containers/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STL Containers</h1><div class=post-meta><span title='2023-08-30 14:13:22 +0800 HKT'>August 30, 2023</span>&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p>In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I&rsquo;ve been revisiting fundamental graph algorithms, I&rsquo;ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.</p><p>They are:</p><ul><li><strong>C++98</strong>: <code>std::map, std::set, std::multimap, and std::multiset</code></li><li><strong>C++11</strong>: <code>std::unordered_map, std::unordered_set, std::unordered_multimap, and std::unordered_multiset</code></li><li><strong>C++23</strong>: <code>std::flat_map, std::flat_set, std::flat_multimap, and std::flat_multiset</code></li></ul><h2 id=sequence-containers>Sequence Containers<a hidden class=anchor aria-hidden=true href=#sequence-containers>#</a></h2><p>Data structures which can be accessed sequentially.</p><ul><li><code>std::array&lt;T,size></code></li><li><code>std::vector&lt;T></code></li><li><code>std::deque&lt;T></code></li><li><code>std::list&lt;T></code></li><li><code>std::forward_list&lt;T></code></li></ul><p><img loading=lazy src=sequence.png alt="Sequence Containers"></p><h2 id=associative-containers>Associative Containers<a hidden class=anchor aria-hidden=true href=#associative-containers>#</a></h2><p>Sorted data structures (i.e., balanced binary search tree) that can be quickly searched (O(log n) complexity).</p><ul><li><code>std::set&lt;T></code></li><li><code>std::multiset&lt;T></code></li><li><code>std::map&lt;Key, Value></code></li><li><code>std::multimap&lt;Key, Value></code></li></ul><p><img loading=lazy src=associative.png alt="Associative Containers"></p><p>Typically, an associate container consists a data type(s), a comparison function, and an allocator</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>         <span class=k>typename</span> <span class=n>Value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=k>typename</span> <span class=n>Compare</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>less</span><span class=o>&lt;</span><span class=n>key</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=k>typename</span> <span class=n>Allocator</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Key</span><span class=p>,</span> <span class=n>Value</span><span class=o>&gt;&gt;&gt;</span>
</span></span></code></pre></div><h2 id=unordered-associative-containers>Unordered Associative Containers<a hidden class=anchor aria-hidden=true href=#unordered-associative-containers>#</a></h2><p>Unsorted data structures (i.e., hashing bucket) that can be quickly searched (O(1) average, O(n) worst-case complexity).</p><ul><li><code>std::unordered_set&lt;T></code></li><li><code>std::unordered_map&lt;Key, Value></code></li><li><code>std::unordered_multiset&lt;T></code></li><li><code>std::unordered_multimap&lt;Key, Value></code></li></ul><p><img loading=lazy src=unordered.png alt="Unordered Containers"></p><p>Typically, an unordered associate container consists a data type(s), a hash function, an equal function and an allocator. The equal function indicates this type of containers does not provide support for comparison.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Hash</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>hash</span><span class=o>&lt;</span><span class=n>Key</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>KeyEqual</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>equal_to</span><span class=o>&lt;</span><span class=n>Key</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Allocator</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Key</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span></code></pre></div><h1 id=container-adaptors>Container adaptors<a hidden class=anchor aria-hidden=true href=#container-adaptors>#</a></h1><p>A different interface for sequential containers.</p><ul><li><code>std::stack&lt;T></code></li><li><code>std::queue&lt;T></code></li><li><code>std::priority_queue&lt;T></code></li><li><code>std::flat_set</code> (c++23)</li><li><code>std::flat_map</code> (c++23)</li><li><code>std::flat_multiset</code> (c++23)</li><li><code>std::flat_multimap</code> (c++23)</li></ul><p>The flat-ordered associative containers in C++23 have the same interface as their C++98 pendants. They adopt from sequence containers, e.g., <code>std::vector</code> by default.</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href="https://www.youtube.com/watch?v=ZMUKa2kWtTk&amp;t=1s">[1] Back to Basics: Standard Library Containers in Cpp - Rainer Grimm - CppCon 2022</a></p><p><a href=https://www.modernescpp.com/index.php/c23-four-new-associative-containers/>[2] C++23: Four new Associative Containers</a></p><p><a href="https://www.youtube.com/watch?v=F4n3ModsWHI&amp;list=PL6NrtSSUk9t9M_Rk-6YkW9u5RJym-SuWZ&amp;t=2430">[3] Refresher on Containers, Algorithms and Performance in C++ - Vladimir Vishnevskii - CppCon 2022</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/stl/>STL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>