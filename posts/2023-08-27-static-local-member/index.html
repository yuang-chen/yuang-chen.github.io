<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Static Local Member | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="C++ templates are blueprints and don&rsquo;t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include<iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template<typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component<A> {}; class B : public Component<B> {}; class C : public Component<C> {}; int main() { std::cout << A::component_type_id() << std::endl; // 0 std::cout << B::component_type_id() << std::endl; // 1 std::cout << B::component_type_id() << std::endl; // 1 std::cout << A::component_type_id() << std::endl; // 0 std::cout << A::component_type_id() << std::endl; // 0 std::cout << C::component_type_id() << std::endl; // 2 } Key Points:"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-08-27-static-local-member/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Static Local Member"><meta property="og:description" content="C++ templates are blueprints and don&rsquo;t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include<iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template<typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component<A> {}; class B : public Component<B> {}; class C : public Component<C> {}; int main() { std::cout << A::component_type_id() << std::endl; // 0 std::cout << B::component_type_id() << std::endl; // 1 std::cout << B::component_type_id() << std::endl; // 1 std::cout << A::component_type_id() << std::endl; // 0 std::cout << A::component_type_id() << std::endl; // 0 std::cout << C::component_type_id() << std::endl; // 2 } Key Points:"><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-08-27-static-local-member/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-27T11:45:15+08:00"><meta property="article:modified_time" content="2023-08-27T11:45:15+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Static Local Member"><meta name=twitter:description content="C++ templates are blueprints and don&rsquo;t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include<iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template<typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component<A> {}; class B : public Component<B> {}; class C : public Component<C> {}; int main() { std::cout << A::component_type_id() << std::endl; // 0 std::cout << B::component_type_id() << std::endl; // 1 std::cout << B::component_type_id() << std::endl; // 1 std::cout << A::component_type_id() << std::endl; // 0 std::cout << A::component_type_id() << std::endl; // 0 std::cout << C::component_type_id() << std::endl; // 2 } Key Points:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Static Local Member","item":"https://yuang-chen.github.io/posts/2023-08-27-static-local-member/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Static Local Member","name":"Static Local Member","description":"C++ templates are blueprints and don\u0026rsquo;t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.\n///////////////////// // Code Block 1 ///////////////////// #include\u0026lt;iostream\u0026gt; class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template\u0026lt;typename T\u0026gt; class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component\u0026lt;A\u0026gt; {}; class B : public Component\u0026lt;B\u0026gt; {}; class C : public Component\u0026lt;C\u0026gt; {}; int main() { std::cout \u0026lt;\u0026lt; A::component_type_id() \u0026lt;\u0026lt; std::endl; // 0 std::cout \u0026lt;\u0026lt; B::component_type_id() \u0026lt;\u0026lt; std::endl; // 1 std::cout \u0026lt;\u0026lt; B::component_type_id() \u0026lt;\u0026lt; std::endl; // 1 std::cout \u0026lt;\u0026lt; A::component_type_id() \u0026lt;\u0026lt; std::endl; // 0 std::cout \u0026lt;\u0026lt; A::component_type_id() \u0026lt;\u0026lt; std::endl; // 0 std::cout \u0026lt;\u0026lt; C::component_type_id() \u0026lt;\u0026lt; std::endl; // 2 } Key Points:","keywords":["C++"],"articleBody":"C++ templates are blueprints and don’t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.\n///////////////////// // Code Block 1 ///////////////////// #include class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template\u003ctypename T\u003e class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component\u003cA\u003e {}; class B : public Component\u003cB\u003e {}; class C : public Component\u003cC\u003e {}; int main() { std::cout \u003c\u003c A::component_type_id() \u003c\u003c std::endl; // 0 std::cout \u003c\u003c B::component_type_id() \u003c\u003c std::endl; // 1 std::cout \u003c\u003c B::component_type_id() \u003c\u003c std::endl; // 1 std::cout \u003c\u003c A::component_type_id() \u003c\u003c std::endl; // 0 std::cout \u003c\u003c A::component_type_id() \u003c\u003c std::endl; // 0 std::cout \u003c\u003c C::component_type_id() \u003c\u003c std::endl; // 2 } Key Points:\ncomponent_type_count belongs to the base class ComponentBase but shared by all derived classes. A unique ID belongs to every instantiated class (e.g., A, B, C). In code block 1, the component_type_id() function has a static local variable ID. When this function is called for the first time for a particular type T, the ID variable is initialized with the current value of component_type_count and then component_type_count is incremented. For all subsequent calls to this function for the same type T, the ID variable retains its value from the first call and just returns that value. Essentially, each type T gets a unique ID the first time this function is called, and the same ID is returned for all subsequent calls.\n///////////////////// // Code Block 2 ///////////////////// template\u003ctypename T\u003e class Component : public ComponentBase{ public: static size_t component_type_id(){ return component_type_count++; } }; // print: 0 1 2 3 4 5 In code block 2, the component_type_id() function increments and returns the value of component_type_count every time it’s called, regardless of the type T. So, unlike the first block, every call to component_type_id() for a given type T will return a new, incremented value.\n","wordCount":"373","inLanguage":"en","datePublished":"2023-08-27T11:45:15+08:00","dateModified":"2023-08-27T11:45:15+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-08-27-static-local-member/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Static Local Member</h1><div class=post-meta><span title='2023-08-27 11:45:15 +0800 CST'>August 27, 2023</span>&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p>C++ templates are blueprints and don&rsquo;t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/////////////////////
</span></span></span><span class=line><span class=cl><span class=c1>// Code Block 1
</span></span></span><span class=line><span class=cl><span class=c1>/////////////////////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span><span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ComponentBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// component_type_count is a static variable shared by derived classes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kr>inline</span> <span class=n>size_t</span> <span class=n>component_type_count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Component</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ComponentBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>size_t</span> <span class=n>component_type_id</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ID is the static local variable for a particular type T
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>static</span> <span class=n>size_t</span> <span class=n>ID</span> <span class=o>=</span> <span class=n>component_type_count</span><span class=o>++</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ID</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Component</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Component</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Component</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>A</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>B</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>B</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>A</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>A</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>C</span><span class=o>::</span><span class=n>component_type_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Key Points:</p><ul><li><code>component_type_count</code> belongs to the <strong>base</strong> class <code>ComponentBase</code> but shared by all <strong>derived</strong> classes.</li><li>A unique <code>ID</code> belongs to every <strong>instantiated</strong> class (e.g., <code>A, B, C</code>).</li></ul><p>In code block 1, the <code>component_type_id()</code> function has a <code>static local variable ID</code>. When this function is called for the first time for a particular type <code>T</code>, the <code>ID</code> variable is initialized with the current value of <code>component_type_count</code> and then <code>component_type_count</code> is incremented. For all subsequent calls to this function for the same type <code>T</code>, the <code>ID</code> variable retains its value from the first call and just returns that value. Essentially, each type <code>T</code> gets a unique <code>ID</code> the first time this function is called, and the same <code>ID</code> is returned for all subsequent calls.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/////////////////////
</span></span></span><span class=line><span class=cl><span class=c1>// Code Block 2
</span></span></span><span class=line><span class=cl><span class=c1>/////////////////////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Component</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ComponentBase</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>size_t</span> <span class=n>component_type_id</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>component_type_count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// print: 0 1 2 3 4 5
</span></span></span></code></pre></div><p>In code block 2, the <code>component_type_id()</code> function increments and returns the value of <code>component_type_count</code> every time it&rsquo;s called, regardless of the type <code>T</code>. So, unlike the first block, every call to <code>component_type_id()</code> for a given type <code>T</code> will return a new, incremented value.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>