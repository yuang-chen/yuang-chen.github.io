<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Parallel Algorithms from Libraries | Yac's Log</title><meta name=keywords content="c++,performance"><meta name=description content="The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.
C++17 new feature &ndash; parallel algorithms The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to CppReference, only GCC and Intel support these features. Clang still leaves them unimplemented.
A blog about it.
The parallel library brough by C++17 requires the usage of Intel&rsquo;s oneTBB for multithreading."><meta name=author content="Yac"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-04-25-par-algo/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Parallel Algorithms from Libraries"><meta property="og:description" content="The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.
C++17 new feature &ndash; parallel algorithms The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to CppReference, only GCC and Intel support these features. Clang still leaves them unimplemented.
A blog about it.
The parallel library brough by C++17 requires the usage of Intel&rsquo;s oneTBB for multithreading."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-04-25-par-algo/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-25T10:16:34+08:00"><meta property="article:modified_time" content="2023-04-25T10:16:34+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Parallel Algorithms from Libraries"><meta name=twitter:description content="The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.
C++17 new feature &ndash; parallel algorithms The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to CppReference, only GCC and Intel support these features. Clang still leaves them unimplemented.
A blog about it.
The parallel library brough by C++17 requires the usage of Intel&rsquo;s oneTBB for multithreading."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Parallel Algorithms from Libraries","item":"https://yuang-chen.github.io/posts/2023-04-25-par-algo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Parallel Algorithms from Libraries","name":"Parallel Algorithms from Libraries","description":"The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.\nC++17 new feature \u0026ndash; parallel algorithms The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to CppReference, only GCC and Intel support these features. Clang still leaves them unimplemented.\nA blog about it.\nThe parallel library brough by C++17 requires the usage of Intel\u0026rsquo;s oneTBB for multithreading.","keywords":["c++","performance"],"articleBody":"The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.\nC++17 new feature â€“ parallel algorithms The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to CppReference, only GCC and Intel support these features. Clang still leaves them unimplemented.\nA blog about it.\nThe parallel library brough by C++17 requires the usage of Intelâ€™s oneTBB for multithreading.\nHowever, there are version conflicts between gcc and oneTBB, as mentioned in issue1 and issue2. Thus, we need to match the gcc with oneTBB for correct version:\ng++11 with oneTBB.2021 (tested). g++9/10 with oneTBB.2019 (untested). Moreoever, the TBB-backboned parallel algorithms does not promise superior performance (perphase due to the implementation overheads), according to the discussion here. Programmers may need to implement their own parallel algorithms to achieve optimal speed.\nFast Parallel Algorithms For implementation, we test std::, tbb-based std::parallel with par and par_unseq, and gnu_parallel for performance evaluation. gnu_parallel performs as the fastest toolkits.\nTODO: I should implement all those algorithms by myself in the near future.\nSorting gnu_parallel is favored by someones\nWhen operating on a vector of size 2^31, the performance of various implementations are:\nmethods time (10^-6s) std:: 15.87 par 2373.95 par_unseq 11.50 gnu_parallel 6.54 Prefix Sum It is also a well-studied algorithm, as descripted by link.\nWhen operating on a vector of size 2^31, the performance of various implementations are:\nmethods time (10^-6s) std:: 5.08 par 5.58 par_unseq 5.42 gnu_parallel 4.25 Conclusion libstdc++ offers built-in parallel implementations for a variety of algorithms, including sort and partial_sum. The parallel mode is implicitly enabled during the compilation with -fopenmp and _GLIBCXX_PARALLEL.\nMoreover, the parallel components called by e.g., std::sort are in fact the gnu_parallel codes. We can also explicitly call gnu_parallel by including the header, e.g.,. Compared with the parallel std::, gnu_parallel incurs smaller overhead and thus delivers (slightly) better performance.\nThe tbb-based parallel methods, which is the new feature of C++17, are unsatisfactory. The par policy behaves extremely poorly in Sorting and a bit bad in Prefix Sum. Suprisingly, the par_unseq policy (parallelism + vectorization) is rather good in Sorting, only second to gnu_parallel. The TBB and its optimization strategies remain to be explored in the future.\nMore details regarding gnu_parallel can be found on this page.\n","wordCount":"382","inLanguage":"en","datePublished":"2023-04-25T10:16:34+08:00","dateModified":"2023-04-25T10:16:34+08:00","author":{"@type":"Person","name":"Yac"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-04-25-par-algo/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Parallel Algorithms from Libraries</h1><div class=post-meta><span title='2023-04-25 10:16:34 +0800 HKT'>April 25, 2023</span>&nbsp;Â·&nbsp;382 words&nbsp;Â·&nbsp;Yac</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#c17-new-feature----parallel-algorithms>C++17 new feature &ndash; parallel algorithms</a></li><li><a href=#fast-parallel-algorithms>Fast Parallel Algorithms</a><ul><li><a href=#sorting>Sorting</a></li><li><a href=#prefix-sum>Prefix Sum</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The content of this post is extracted from my previous random notes. I am too lazy to update and organize it ðŸ¦¥.</p><h2 id=c17-new-feature----parallel-algorithms>C++17 new feature &ndash; parallel algorithms<a hidden class=anchor aria-hidden=true href=#c17-new-feature----parallel-algorithms>#</a></h2><p>The parallel algorithms and execution policies are introduced in C++17. Unfortuantely, according to <a href=https://en.cppreference.com/w/cpp/compiler_support>CppReference</a>, only GCC and Intel support these features. Clang still leaves them unimplemented.</p><p>A <a href=http://www.modernescpp.com/index.php/component/jaggyblog/c-17-new-algorithm-of-the-standard-template-library>blog</a> about it.</p><p>The <em>parallel</em> library brough by C++17 requires the usage of Intel&rsquo;s oneTBB for multithreading.<br>However, there are version conflicts between gcc and oneTBB, as mentioned in <a href=https://community.intel.com/t5/Intel-oneAPI-Threading-Building/tbb-task-has-not-been-declared/td-p/1254418>issue1</a> and <a href=https://forum.qt.io/topic/122225/trying-to-use-c-17-parallel-algorithms-with-qt/9>issue2</a>. Thus, we need to match the gcc with oneTBB for correct version:</p><ol><li><code>g++11</code> with <code>oneTBB.2021</code> (tested).</li><li><code>g++9/10</code> with <code>oneTBB.2019</code> (untested).</li></ol><p>Moreoever, the TBB-backboned parallel algorithms does not promise superior performance (perphase due to the implementation overheads), according to the discussion <a href=https://stackoverflow.com/questions/51031060/are-c17-parallel-algorithms-implemented-already>here</a>. Programmers may need to implement their own parallel algorithms to achieve optimal speed.</p><h2 id=fast-parallel-algorithms>Fast Parallel Algorithms<a hidden class=anchor aria-hidden=true href=#fast-parallel-algorithms>#</a></h2><p>For implementation, we test <code>std::</code>, tbb-based <code>std::parallel</code> with <code>par</code> and <code>par_unseq</code>, and <code>gnu_parallel</code> for performance evaluation. <code>gnu_parallel</code> performs as the fastest toolkits.</p><p><strong>TODO: I should implement all those algorithms by myself in the near future.</strong></p><h3 id=sorting>Sorting<a hidden class=anchor aria-hidden=true href=#sorting>#</a></h3><p><code>gnu_parallel</code> is favored by <a href=https://stackoverflow.com/questions/61918660/parallel-sorting-of-stdvector-in-cpp>someones</a></p><p>When operating on a vector of size 2^31, the performance of various implementations are:</p><table><thead><tr><th>methods</th><th>time (10^-6s)</th></tr></thead><tbody><tr><td><code>std::</code></td><td>15.87</td></tr><tr><td><code>par</code></td><td>2373.95</td></tr><tr><td><code>par_unseq</code></td><td>11.50</td></tr><tr><td><strong><code>gnu_parallel</code></strong></td><td>6.54</td></tr></tbody></table><h3 id=prefix-sum>Prefix Sum<a hidden class=anchor aria-hidden=true href=#prefix-sum>#</a></h3><p>It is also a well-studied algorithm, as descripted by
<a href=https://stackoverflow.com/questions/10053629/parallel-prefix-sum-fastest-implementation>link</a>.</p><p>When operating on a vector of size 2^31, the performance of various implementations are:</p><table><thead><tr><th>methods</th><th>time (10^-6s)</th></tr></thead><tbody><tr><td><code>std::</code></td><td>5.08</td></tr><tr><td><code>par</code></td><td>5.58</td></tr><tr><td><code>par_unseq</code></td><td>5.42</td></tr><tr><td><strong><code>gnu_parallel</code></strong></td><td>4.25</td></tr></tbody></table><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>libstdc++ offers built-in parallel implementations for a variety of algorithms, including <code>sort</code> and <code>partial_sum</code>. The parallel mode is implicitly enabled during the compilation with <code>-fopenmp</code> and <code>_GLIBCXX_PARALLEL</code>.</p><p>Moreover, the parallel components called by e.g., <code>std::sort</code> are in fact the <code>gnu_parallel</code> codes. We can also explicitly call <code>gnu_parallel</code> by including the header, e.g.,<code>&lt;parallel/algorithm></code>. Compared with the parallel <code>std::</code>, <code>gnu_parallel</code> incurs smaller overhead and thus delivers (slightly) better performance.</p><p>The tbb-based parallel methods, which is the new feature of C++17, are unsatisfactory. The <code>par</code> policy behaves extremely poorly in Sorting and a bit bad in Prefix Sum. Suprisingly, the <code>par_unseq</code> policy (parallelism + vectorization) is rather good in Sorting, only second to <code>gnu_parallel</code>. The <em>TBB and its optimization strategies</em> remain to be explored in the future.</p><p>More details regarding <code>gnu_parallel</code> can be found on this <a href=https://gcc.gnu.org/onlinedocs/libstdc++/manual/parallel_mode_using.html#parallel_mode.using.specific>page</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>c++</a></li><li><a href=https://yuang-chen.github.io/tags/performance/>performance</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>