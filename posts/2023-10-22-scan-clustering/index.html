<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SCAN Clustering | Yac's Log</title><meta name=keywords content><meta name=description content="Note The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the structural similarity between nodes:
$$ s(A, B) = \frac{|N(A) \cap N(B)|}{\sqrt{|N(A)| \times |N(B)|}} $$
Compute Structural Similarity: For each edge (A,B)(A,B), compute its structural similarity score. Identify Strong Relations: Mark edges as &lsquo;strong&rsquo; if their structural similarity is above **eps. Identify Core Nodes: For each node, count its strong relationships."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-10-22-scan-clustering/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="SCAN Clustering"><meta property="og:description" content="Note The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the structural similarity between nodes:
$$ s(A, B) = \frac{|N(A) \cap N(B)|}{\sqrt{|N(A)| \times |N(B)|}} $$
Compute Structural Similarity: For each edge (A,B)(A,B), compute its structural similarity score. Identify Strong Relations: Mark edges as &lsquo;strong&rsquo; if their structural similarity is above **eps. Identify Core Nodes: For each node, count its strong relationships."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-10-22-scan-clustering/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-22T16:10:09+08:00"><meta property="article:modified_time" content="2023-10-22T16:10:09+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="SCAN Clustering"><meta name=twitter:description content="Note The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the structural similarity between nodes:
$$ s(A, B) = \frac{|N(A) \cap N(B)|}{\sqrt{|N(A)| \times |N(B)|}} $$
Compute Structural Similarity: For each edge (A,B)(A,B), compute its structural similarity score. Identify Strong Relations: Mark edges as &lsquo;strong&rsquo; if their structural similarity is above **eps. Identify Core Nodes: For each node, count its strong relationships."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SCAN Clustering","item":"https://yuang-chen.github.io/posts/2023-10-22-scan-clustering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SCAN Clustering","name":"SCAN Clustering","description":"Note The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the structural similarity between nodes:\n$$ s(A, B) = \\frac{|N(A) \\cap N(B)|}{\\sqrt{|N(A)| \\times |N(B)|}} $$\nCompute Structural Similarity: For each edge (A,B)(A,B), compute its structural similarity score. Identify Strong Relations: Mark edges as \u0026lsquo;strong\u0026rsquo; if their structural similarity is above **eps. Identify Core Nodes: For each node, count its strong relationships.","keywords":[],"articleBody":"Note The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the structural similarity between nodes:\n$$ s(A, B) = \\frac{|N(A) \\cap N(B)|}{\\sqrt{|N(A)| \\times |N(B)|}} $$\nCompute Structural Similarity: For each edge (A,B)(A,B), compute its structural similarity score. Identify Strong Relations: Mark edges as ‘strong’ if their structural similarity is above **eps. Identify Core Nodes: For each node, count its strong relationships. If it has more than mu strong relationships, mark it as a core node. Cluster Formation: Perform a DFS starting from each core node to form clusters. Classify Non-Core Nodes: Nodes that are not core nodes but are connected to core nodes are considered as border nodes. Nodes that are neither core nodes nor connected to core nodes are considered as outliers. Complexity Analysis: Computing Structural Similarity: In the worst case, this step has a time complexity of $O(∣E∣×d)$, where $∣E∣$ is the number of edges and $d$ is the average degree of the nodes. Identifying Strong Relations and Core Nodes: This can be done in $O(∣E∣+∣V∣)$ time, where ∣V∣ is the number of vertices. Cluster Formation: The DFS steps have a time complexity of $O(∣E∣+∣V∣)$ So, the overall worst-case time complexity is $O(∣E∣×d+∣V∣)$\nThe space complexity is $O(∣E∣+∣V∣)$ to store the graph and additional data structures.\nCode #include #include #include #include auto SCAN(const std::vector\u003cint\u003e row_ptr, const std::vector\u003cint\u003e col_idx, double eps, int mu) { // \u003c\u003c Compute the structural similarity between two nodes auto structure_similarity = [\u0026](int source, int target) { auto source_begin = row_ptr[source]; auto target_begin = row_ptr[target]; const auto source_end = row_ptr[source + 1]; const auto target_end = row_ptr[target + 1]; const auto source_degree = source_end - source_begin; const auto target_degree = target_end - target_begin; if (source_degree == 0 || target_degree == 0) { return 0.0; } int common_neighbors = 0; while (source_begin \u003c source_end \u0026\u0026 target_begin \u003c target_end) { if (col_idx[source_begin] == col_idx[target_begin]) { ++common_neighbors; ++source_begin; ++target_begin; } else if (col_idx[source_begin] \u003c col_idx[target_begin]) { ++source_begin; } else { ++target_begin; } } return static_cast\u003cdouble\u003e(common_neighbors) / std::sqrt(source_degree * target_degree); }; // \u003c\u003c Construct a new cluster from the core node std::function\u003cvoid(int, std::unordered_set\u003cint\u003e \u0026, const std::vector\u003cstd::unordered_set\u003cint\u003e\u003e \u0026)\u003e dfs = [\u0026dfs]( int source, std::unordered_set\u003cint\u003e \u0026new_cluster, const std::vector\u003cstd::unordered_set\u003cint\u003e\u003e \u0026strong_neighbors) { new_cluster.insert(source); for (const auto target : strong_neighbors[source]) { if (new_cluster.find(target) == new_cluster.end()) { dfs(target, new_cluster, strong_neighbors); } } }; //\u003e\u003e Find Core Nodes const auto num_nodes = row_ptr.size() - 1; std::vector\u003cstd::unordered_set\u003cint\u003e\u003e strong_neighbors(num_nodes); std::unordered_set\u003cint\u003e core_nodes; for (int source = 0; source \u003c num_nodes; source++) { for (int j = row_ptr[source]; j \u003c row_ptr[source + 1]; j++) { auto target = col_idx[j]; // 1. For each vertex, compute its structural similarity with its // neighbors. if (structure_similarity(source, target) \u003e eps) { // 2. If the structural similarity is above a certain threshold // (eps), mark the edge as 'strong'. strong_neighbors[source].insert(target); } } // 3. For each vertex, if the number of strong neighbors is above a // certain threshold (mu), mark it as a 'core' vertex. if (strong_neighbors[source].size() \u003e= mu) { core_nodes.insert(source); } } // std::cout \u003c\u003c \"Strong Neighbors: \" \u003c\u003c std::endl; // for (int i = 0; i \u003c strong_neighbors.size(); ++i) { // std::cout \u003c\u003c \"Node \" \u003c\u003c i \u003c\u003c \": \"; // for (const auto \u0026neighbor : strong_neighbors[i]) { // std::cout \u003c\u003c neighbor \u003c\u003c \" \"; // } // std::cout \u003c\u003c std::endl; // } // std::cout \u003c\u003c \"Core Nodes: \" \u003c\u003c std::endl; // for (const auto \u0026node : core_nodes) { // std::cout \u003c\u003c node \u003c\u003c \" \"; // } // std::cout \u003c\u003c std::endl; // \u003e\u003e Find Clusters std::vector\u003cstd::unordered_set\u003cint\u003e\u003e clusters; std::unordered_set\u003cint\u003e visited; // 4. Perform a DFS to find clusters // starting from each core node for (const auto core : core_nodes) { if (visited.find(core) == visited.end()) { std::unordered_set\u003cint\u003e new_cluster; dfs(core, new_cluster, strong_neighbors); clusters.push_back(new_cluster); visited.insert(new_cluster.begin(), new_cluster.end()); } } return clusters; } int main() { std::vector\u003cint\u003e row_ptr = {0, 4, 8, 12, 16, 17, 21, 25, 29, 33, 34}; std::vector\u003cint\u003e col_idx = {1, 2, 3, 0, 0, 2, 3, 1, 0, 1, 3, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 6, 7, 8, 5, 6, 7, 8, 5, 6, 7, 8, 9}; // Parameters for SCAN double eps = 0.7; int mu = 2; auto clusters = SCAN(row_ptr, col_idx, eps, mu); for (const auto \u0026cluster : clusters) { for (const auto node : cluster) { std::cout \u003c\u003c node \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } return 0; } ","wordCount":"734","inLanguage":"en","datePublished":"2023-10-22T16:10:09+08:00","dateModified":"2023-10-22T16:10:09+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-10-22-scan-clustering/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SCAN Clustering</h1><div class=post-meta><span title='2023-10-22 16:10:09 +0800 CST'>October 22, 2023</span>&nbsp;·&nbsp;734 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h2 id=note>Note<a hidden class=anchor aria-hidden=true href=#note>#</a></h2><p>The SCAN (Structural Clustering Algorithm for Networks) algorithm is used for detecting clusters in graphs. It also looks at the <strong>structural similarity</strong> between nodes:</p><p>$$
s(A, B) = \frac{|N(A) \cap N(B)|}{\sqrt{|N(A)| \times |N(B)|}}
$$</p><ol><li><strong>Compute Structural Similarity</strong>: For each edge (A,B)(<em>A</em>,<em>B</em>), compute its structural similarity score.</li><li><strong>Identify Strong Relations</strong>: Mark edges as &lsquo;strong&rsquo; if their structural similarity is above **<code>eps</code>.</li><li><strong>Identify Core Nodes</strong>: For each node, count its strong relationships. If it has more than <code>mu</code> strong relationships, mark it as a core node.</li><li><strong>Cluster Formation</strong>: Perform a DFS starting from each core node to form clusters.</li><li><strong>Classify Non-Core Nodes</strong>: Nodes that are not core nodes but are connected to core nodes are considered as border nodes. Nodes that are neither core nodes nor connected to core nodes are considered as outliers.</li></ol><h3 id=complexity-analysis><strong>Complexity Analysis:</strong><a hidden class=anchor aria-hidden=true href=#complexity-analysis>#</a></h3><ol><li><strong>Computing Structural Similarity</strong>: In the worst case, this step has a time complexity of $O(∣E∣×d)$, where $∣E∣$ is the number of edges and $<em>d</em>$ is the average degree of the nodes.</li><li><strong>Identifying Strong Relations and Core Nodes</strong>: This can be done in $O(∣E∣+∣V∣)$ time, where ∣V∣ is the number of vertices.</li><li><strong>Cluster Formation</strong>: The DFS steps have a time complexity of $O(∣E∣+∣V∣)$</li></ol><p>So, the overall worst-case time complexity is $O(∣E∣×d+∣V∣)$</p><p>The space complexity is $O(∣E∣+∣V∣)$ to store the graph and additional data structures.</p><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cmath&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unordered_set&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>SCAN</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>row_ptr</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>col_idx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>double</span> <span class=n>eps</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mu</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;&lt; Compute the structural similarity between two nodes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>structure_similarity</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>source</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>source_begin</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>target_begin</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=k>auto</span> <span class=n>source_end</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=k>auto</span> <span class=n>target_end</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=k>auto</span> <span class=n>source_degree</span> <span class=o>=</span> <span class=n>source_end</span> <span class=o>-</span> <span class=n>source_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=k>auto</span> <span class=n>target_degree</span> <span class=o>=</span> <span class=n>target_end</span> <span class=o>-</span> <span class=n>target_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>source_degree</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>target_degree</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>common_neighbors</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>source_begin</span> <span class=o>&lt;</span> <span class=n>source_end</span> <span class=o>&amp;&amp;</span> <span class=n>target_begin</span> <span class=o>&lt;</span> <span class=n>target_end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>col_idx</span><span class=p>[</span><span class=n>source_begin</span><span class=p>]</span> <span class=o>==</span> <span class=n>col_idx</span><span class=p>[</span><span class=n>target_begin</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>common_neighbors</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>source_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>target_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>col_idx</span><span class=p>[</span><span class=n>source_begin</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>col_idx</span><span class=p>[</span><span class=n>target_begin</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>source_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>target_begin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>common_neighbors</span><span class=p>)</span> <span class=o>/</span>
</span></span><span class=line><span class=cl>               <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=n>source_degree</span> <span class=o>*</span> <span class=n>target_degree</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;&lt; Construct a new cluster from the core node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=o>&amp;</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=o>&amp;</span><span class=n>dfs</span><span class=p>](</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>source</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>new_cluster</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=o>&amp;</span><span class=n>strong_neighbors</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>new_cluster</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=nl>target</span> <span class=p>:</span> <span class=n>strong_neighbors</span><span class=p>[</span><span class=n>source</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>new_cluster</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>target</span><span class=p>)</span> <span class=o>==</span> <span class=n>new_cluster</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>dfs</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>new_cluster</span><span class=p>,</span> <span class=n>strong_neighbors</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//&gt;&gt; Find Core Nodes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>strong_neighbors</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>core_nodes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>source</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>source</span> <span class=o>&lt;</span> <span class=n>num_nodes</span><span class=p>;</span> <span class=n>source</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>target</span> <span class=o>=</span> <span class=n>col_idx</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 1. For each vertex, compute its structural similarity with its
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// neighbors.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>structure_similarity</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>eps</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 2. If the structural similarity is above a certain threshold
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// (eps), mark the edge as &#39;strong&#39;.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>strong_neighbors</span><span class=p>[</span><span class=n>source</span><span class=p>].</span><span class=n>insert</span><span class=p>(</span><span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 3. For each vertex, if the number of strong neighbors is above a
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// certain threshold (mu), mark it as a &#39;core&#39; vertex.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>strong_neighbors</span><span class=p>[</span><span class=n>source</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>mu</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>core_nodes</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// std::cout &lt;&lt; &#34;Strong Neighbors: &#34; &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// for (int i = 0; i &lt; strong_neighbors.size(); ++i) {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     std::cout &lt;&lt; &#34;Node &#34; &lt;&lt; i &lt;&lt; &#34;: &#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     for (const auto &amp;neighbor : strong_neighbors[i]) {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//         std::cout &lt;&lt; neighbor &lt;&lt; &#34; &#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     std::cout &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; &#34;Core Nodes: &#34; &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// for (const auto &amp;node : core_nodes) {
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     std::cout &lt;&lt; node &lt;&lt; &#34; &#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// &gt;&gt; Find Clusters
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>clusters</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>visited</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//    4. Perform a DFS to find clusters
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    starting from each core node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=nl>core</span> <span class=p>:</span> <span class=n>core_nodes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>visited</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>core</span><span class=p>)</span> <span class=o>==</span> <span class=n>visited</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>new_cluster</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>core</span><span class=p>,</span> <span class=n>new_cluster</span><span class=p>,</span> <span class=n>strong_neighbors</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>clusters</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>new_cluster</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>visited</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>new_cluster</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>new_cluster</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>clusters</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>row_ptr</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>17</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>33</span><span class=p>,</span> <span class=mi>34</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>col_idx</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=mi>8</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Parameters for SCAN
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>eps</span> <span class=o>=</span> <span class=mf>0.7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mu</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>clusters</span> <span class=o>=</span> <span class=n>SCAN</span><span class=p>(</span><span class=n>row_ptr</span><span class=p>,</span> <span class=n>col_idx</span><span class=p>,</span> <span class=n>eps</span><span class=p>,</span> <span class=n>mu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>cluster</span> <span class=p>:</span> <span class=n>clusters</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=nl>node</span> <span class=p>:</span> <span class=n>cluster</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>node</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>