<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Minimum Spanning Tree | Yac's Log</title><meta name=keywords content><meta name=description content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Minimum Spanning Tree"><meta property="og:description" content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-29T10:34:39+08:00"><meta property="article:modified_time" content="2023-09-29T10:34:39+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Minimum Spanning Tree"><meta name=twitter:description content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Minimum Spanning Tree","item":"https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Minimum Spanning Tree","name":"Minimum Spanning Tree","description":"Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it\u0026rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.","keywords":[],"articleBody":"Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it’s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.\nThere are two techniques that can be employed to find the MST of a graph: the min heap (implemented as a priority queue in C++) and the union-find. The algorithms for finding MST using these two techniques are known as Prim’s algorithm and Kruskal’s algorithm, respectively. The code structure for implementing these algorithms is quite similar to that of previous graph algorithms such as SSSP and Connected Components\nMin Heap Prim’s algorithm is based on min heap, which is highly similar to Dijkstra’s algorithm for SSSP. Both use a priory_queue to keep the minimum distance and a visited frontier to avoid redundant traversal. Even the code structure are almost the same as well as time complexity $O((V+E)log(V))$.\nThe key difference lies in the definition, evaluation and calculation of distance.\nPrim’s : distance[target] = weight; In each step, the edge with the smallest weight that connects a vertex in the MST to a vertex outside it is chosen. Consequently, a Minimum Spanning Tree is produced, which is a subgraph that includes all vertices and has (V - 1) edges. Dijkstra’s: distance[target] = distance[curr] + weight; In each step, the vertex with the smallest distance from the root vertex is chosen, and its neighbors are updated. Consequently, a Shortest-Path Tree is produced, which may not include all vertices and edges but will provide the shortest path from the source vertex to all reachable vertices. Union Find Kruskal’s algorithm employs the union-find approach, which is commonly used by (Weakly) Connected Components. The key distinction is that MST iterates through the edges sorted by weight, whereas CC can traverse the unweighted edge in any order.\nMin Heap vs Union Find The following table provides a comparison between the min heap and union-find approaches for finding the MST.\nCriteria Prim’s Algorithm Kruskal’s Algorithm Technique Min Heap (Priority Queue) Union-Find Graph Type Connected Connected or Disconnected Initialization Single vertex Edge List sorted by weights Time Complexity $O((V + E) \\log V)$ $O(E \\log E)$ Output Parent Array Edge List Solution #include #include #include #include //------------// // Priority Queue // Prim's algorithm to find the minimum spanning tree //------------// auto Prim(const std::vector\u003cint\u003e\u0026 row_pointer, const std::vector\u003cint\u003e\u0026 column_index, const std::vector\u003cfloat\u003e\u0026 values) { // the same setting as Dijkstra's SSSP const auto num_nodes = row_pointer.size() - 1; std::vector\u003cfloat\u003e distance(num_nodes, std::numeric_limits\u003cfloat\u003e::max()); std::vector\u003cint\u003e parent(num_nodes, -1); std::vector\u003cbool\u003e visited(num_nodes, false); std::priority_queue\u003c std::pair\u003cfloat, int\u003e, std::vector\u003cstd::pair\u003cfloat, int\u003e\u003e, std::greater\u003cstd::pair\u003cfloat, int\u003e\u003e\u003e min_heap; // start from vertex 0 min_heap.push({ 0.0, 0 }); distance[0] = 0.0; while(!min_heap.empty()) { auto [dist, source] = min_heap.top(); min_heap.pop(); visited[source] = true; // iterate over all outgoing edges for(auto i = row_pointer[source]; i \u003c row_pointer[source + 1]; i++) { auto target = column_index[i]; auto weight = values[i]; if(!visited[target] \u0026\u0026 weight \u003c distance[target]) { distance[target] = weight; parent[target] = source; min_heap.push({ weight, target }); } } } return parent; } //------------// // Union Find // //------------// auto Kruskal(const std::vector\u003cint\u003e\u0026 row_pointer, const std::vector\u003cint\u003e\u0026 column_index, const std::vector\u003cfloat\u003e\u0026 values){ auto num_nodes = row_pointer.size() - 1; auto num_edges = column_index.size(); std::vector\u003cstd::tuple\u003cint, int, float\u003e\u003e edges; std::vector\u003cstd::tuple\u003cint, int, float\u003e\u003e tree; for(int i = 0; i \u003c num_nodes; i++) { for(auto j = row_pointer[i]; j \u003c row_pointer[i + 1]; j++){ edges.emplace_back(i, column_index[j], values[j]); } } // O(ElogE) -- the most expensive part std::sort(edges.begin(), edges.end(), [](auto\u0026 a, auto\u0026 b){ return std::get\u003c2\u003e(a) \u003c std::get\u003c2\u003e(b); }); std::vector\u003cint\u003e parent(num_nodes); std::vector\u003cint\u003e rank(num_nodes); // keep tree relatively balanced std::iota(parent.begin(), parent.end(), 0); // find auto find = [\u0026parent](int i) { while(parent[i] != i){ i = parent[i]; } return i; }; // union by rank auto unite = [\u0026find, \u0026rank, \u0026parent](int i, int j) { i = find(i); j = find(j); if(rank[i] \u003e rank[j]) { std::swap(i, j); } parent[i] = j; if(rank[i] == rank[j]) { rank[j]++; } }; // O(ElogV) for(const auto [source, target, weight] : edges) { if(find(source) != find(target)) { unite(source, target); tree.emplace_back(source, target, weight); } } return tree; } int main() { std::vector\u003cint\u003e row_pointer = { 0, 3, 5, 7, 10, 12, 14 }; std::vector\u003cint\u003e column_index = { 1, 2, 3, 0, 2, 0, 1, 0, 4, 5, 3, 5, 3, 4 }; std::vector\u003cfloat\u003e values = { 1.2, 3.4, 0.5, 1.2, 4.1, 3.4, 4.1, 0.5, 2.8, 1.9, 2.8, 4.7, 1.9, 4.7}; auto parent = Prim(row_pointer, column_index, values); for(size_t i = 0; i \u003c parent.size(); i++) { std::cout \u003c\u003c parent[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; auto mst = Kruskal(row_pointer, column_index, values); for (const auto\u0026 [u, v, w] : mst) { std::cout \u003c\u003c u \u003c\u003c \" - \" \u003c\u003c v \u003c\u003c \" (Weight: \" \u003c\u003c w \u003c\u003c \") , \"; } std::cout \u003c\u003c std::endl; } ","wordCount":"824","inLanguage":"en","datePublished":"2023-09-29T10:34:39+08:00","dateModified":"2023-09-29T10:34:39+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Minimum Spanning Tree</h1><div class=post-meta><span title='2023-09-29 10:34:39 +0800 HKT'>September 29, 2023</span>&nbsp;·&nbsp;824 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h1><p>A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the <em>minimum possible total edge weight</em> among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.</p><p>There are two techniques that can be employed to find the MST of a graph: the <strong>min heap</strong> (implemented as a priority queue in C++) and the <strong>union-find</strong>. The algorithms for finding MST using these two techniques are known as Prim&rsquo;s algorithm and Kruskal&rsquo;s algorithm, respectively. The code structure for implementing these algorithms is quite similar to that of previous graph algorithms such as SSSP and Connected Components</p><h2 id=min-heap>Min Heap<a hidden class=anchor aria-hidden=true href=#min-heap>#</a></h2><p>Prim&rsquo;s algorithm is based on min heap, which is highly similar to Dijkstra&rsquo;s algorithm for SSSP. Both use a <code>priory_queue</code> to keep the minimum distance and a <code>visited</code> frontier to avoid redundant traversal. Even the code structure are almost the same as well as time complexity $O((V+E)log(V))$.</p><p>The key difference lies in the definition, evaluation and calculation of <strong>distance</strong>.</p><ul><li>Prim’s : <code>distance[target] = weight;</code><ul><li>In each step, the <em>edge</em> with the smallest weight that connects a vertex in the MST to a vertex outside it is chosen.</li><li>Consequently, a Minimum Spanning Tree is produced, which is a subgraph that includes all vertices and has <code>(V - 1)</code> edges.</li></ul></li><li>Dijkstra’s: <code>distance[target] = distance[curr] + weight;</code><ul><li>In each step, the <em>vertex</em> with the smallest distance from the <em>root</em> vertex is chosen, and its neighbors are updated.</li><li>Consequently, a Shortest-Path Tree is produced, which may not include all vertices and edges but will provide the shortest path from the source vertex to all reachable vertices.</li></ul></li></ul><h2 id=union-find>Union Find<a hidden class=anchor aria-hidden=true href=#union-find>#</a></h2><p>Kruskal&rsquo;s algorithm employs the union-find approach, which is commonly used by (Weakly) Connected Components. The key distinction is that MST iterates through the <strong>edges</strong> <strong>sorted by weight</strong>, whereas CC can traverse the <strong>unweighted edge</strong> in any order.</p><h2 id=min-heap-vs-union-find>Min Heap vs Union Find<a hidden class=anchor aria-hidden=true href=#min-heap-vs-union-find>#</a></h2><p>The following table provides a comparison between the min heap and union-find approaches for finding the MST.</p><table><thead><tr><th>Criteria</th><th>Prim&rsquo;s Algorithm</th><th>Kruskal&rsquo;s Algorithm</th></tr></thead><tbody><tr><td>Technique</td><td>Min Heap (Priority Queue)</td><td>Union-Find</td></tr><tr><td>Graph Type</td><td>Connected</td><td>Connected or Disconnected</td></tr><tr><td>Initialization</td><td>Single vertex</td><td>Edge List sorted by weights</td></tr><tr><td>Time Complexity</td><td>$O((V + E) \log V)$</td><td>$O(E \log E)$</td></tr><tr><td>Output</td><td>Parent Array</td><td>Edge List</td></tr></tbody></table><h1 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;numeric&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//------------//
</span></span></span><span class=line><span class=cl><span class=c1>// Priority Queue
</span></span></span><span class=line><span class=cl><span class=c1>// Prim&#39;s algorithm to find the minimum spanning tree
</span></span></span><span class=line><span class=cl><span class=c1>//------------//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>Prim</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>row_pointer</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>column_index</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;&amp;</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the same setting as Dijkstra&#39;s SSSP
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=k>auto</span>         <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>distance</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>parent</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span>  <span class=n>visited</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>priority_queue</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>greater</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;&gt;</span>
</span></span><span class=line><span class=cl>      <span class=n>min_heap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// start from vertex 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>min_heap</span><span class=p>.</span><span class=n>push</span><span class=p>({</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mi>0</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=n>distance</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>min_heap</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=p>[</span><span class=n>dist</span><span class=p>,</span> <span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>min_heap</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>min_heap</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// iterate over all outgoing edges
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>target</span> <span class=o>=</span> <span class=n>column_index</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>weight</span> <span class=o>=</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>target</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>target</span><span class=p>]</span>   <span class=o>=</span> <span class=n>source</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>min_heap</span><span class=p>.</span><span class=n>push</span><span class=p>({</span> <span class=n>weight</span><span class=p>,</span> <span class=n>target</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//------------//
</span></span></span><span class=line><span class=cl><span class=c1>// Union Find //
</span></span></span><span class=line><span class=cl><span class=c1>//------------//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>Kruskal</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>row_pointer</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>column_index</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;&amp;</span> <span class=n>values</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>num_edges</span> <span class=o>=</span> <span class=n>column_index</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;&gt;</span> <span class=n>edges</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;&gt;</span> <span class=n>tree</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_nodes</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>j</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>edges</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>column_index</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// O(ElogE) -- the most expensive part
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>edges</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>edges</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=k>auto</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>parent</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>rank</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>);</span>    <span class=c1>// keep tree relatively balanced
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>iota</span><span class=p>(</span><span class=n>parent</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>parent</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// find 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>find</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>parent</span><span class=p>](</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>=</span> <span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=c1>// union by rank
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>unite</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>find</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rank</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>parent</span><span class=p>](</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>j</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>rank</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>rank</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=c1>// O(ElogV) 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>weight</span><span class=p>]</span> <span class=o>:</span> <span class=n>edges</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>find</span><span class=p>(</span><span class=n>source</span><span class=p>)</span> <span class=o>!=</span> <span class=n>find</span><span class=p>(</span><span class=n>target</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>unite</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>tree</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>weight</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>tree</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>row_pointer</span>  <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>14</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>column_index</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>values</span>       <span class=o>=</span> <span class=p>{</span> <span class=mf>1.2</span><span class=p>,</span> <span class=mf>3.4</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>,</span> <span class=mf>4.1</span><span class=p>,</span> <span class=mf>3.4</span><span class=p>,</span> <span class=mf>4.1</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>2.8</span><span class=p>,</span> <span class=mf>1.9</span><span class=p>,</span> <span class=mf>2.8</span><span class=p>,</span> <span class=mf>4.7</span><span class=p>,</span> <span class=mf>1.9</span><span class=p>,</span> <span class=mf>4.7</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>Prim</span><span class=p>(</span><span class=n>row_pointer</span><span class=p>,</span> <span class=n>column_index</span><span class=p>,</span> <span class=n>values</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>parent</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>mst</span> <span class=o>=</span> <span class=n>Kruskal</span><span class=p>(</span><span class=n>row_pointer</span><span class=p>,</span> <span class=n>column_index</span><span class=p>,</span> <span class=n>values</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>w</span><span class=p>]</span> <span class=o>:</span> <span class=n>mst</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>u</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; - &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; (Weight: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>w</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;) , &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>