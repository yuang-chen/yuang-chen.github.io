<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Virtual Polymorphism | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.
Notice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Non-Virtual Polymorphism"><meta property="og:description" content="Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.
Notice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-24T09:33:57+08:00"><meta property="article:modified_time" content="2024-01-24T09:33:57+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Non-Virtual Polymorphism"><meta name=twitter:description content="Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.
Notice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Non-Virtual Polymorphism","item":"https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Non-Virtual Polymorphism","name":"Non-Virtual Polymorphism","description":"Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.\nNotice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant.","keywords":["C++"],"articleBody":"Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.\nNotice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant.\nFeature Paired With Purpose Use Case Special Notes std::any std::any_cast To store an instance of any type and safely retrieve the stored value. Use std::any when the exact type is unknown or may change, and std::any_cast for retrieval. Type-safe storage for single values. std::any_cast throws an exception if the cast is to the wrong type. std::variant std::visit To store one of several predefined types and apply a function to the variantâ€™s content. Use std::variant when the value can be one of a few known types and std::visit for operations. Type-safe and more constrained than std::any. std::visit requires a callable applicable to all types in the variant. std::tuple std::apply To store a fixed-size collection of heterogeneous values and apply a function to them. Use std::tuple for grouping known types and std::apply to call a function with tuple elements. Accessed by index using std::get. std::apply useful for calling a function with tuple elements as arguments. Code Example std::any #include #include #include int main() { std::any a = 1; // Store an int std::cout \u003c\u003c std::any_cast\u003cint\u003e(a) \u003c\u003c std::endl; // Extract the int a = std::string(\"Hello, World!\"); // Store a string std::cout \u003c\u003c std::any_cast\u003cstd::string\u003e(a) \u003c\u003c std::endl; // Extract the string return 0; } std::variant #include #include #include int main() { // A variant that can hold either an int, double, or string std::variant\u003cint, double, std::string\u003e var; var = 10; // Assigning an integer // Visit the variant and apply a lambda function std::visit([](auto\u0026\u0026 arg) { std::cout \u003c\u003c arg \u003c\u003c std::endl; }, var); var = \"Hello, World!\"; // Now assign a string // Visit the variant again std::visit([](auto\u0026\u0026 arg) { std::cout \u003c\u003c arg \u003c\u003c std::endl; }, var); return 0; } std::tupple #include #include // A function to be applied to a tuple void print(int i, const std::string\u0026 s, double d) { std::cout \u003c\u003c i \u003c\u003c \", \" \u003c\u003c s \u003c\u003c \", \" \u003c\u003c d \u003c\u003c std::endl; } int main() { std::tuple\u003cint, std::string, double\u003e t = std::make_tuple(42, \"Hello\", 3.14); // Apply the function 'print' to the tuple 't' std::apply(print, t); return 0; } CRTP in C++98 The Curiously Recurring Template Pattern (CRTP) is an advanced C++ idiom that involves a particular form of inheritance that leverages templates. It achieves static polymorphism, which allows for polymorphic behavior without the overhead of dynamic polymorphism (such as virtual functions).\nIn CRTP, a template class named Base is designed to take a derived class as its template parameter. When defining a derived class, such as Derived, it inherits from Base by passing itself as the template argument (Base). This allows Base to define an interface which Derived implements, enabling Base to invoke these methods directly.\nThe CRTP enables static (compile-time) polymorphism. By using templates, the base class can call methods of the derived class without needing virtual functions. This is because the base class knows the type of the derived class at compile time.\nUnlike dynamic polymorphism, which uses virtual functions to resolve method calls at runtime, CRTP resolves them at compile time. This eliminates the overhead associated with dynamic dispatch (like v-table lookups).\nCode Example template\u003ctypename Derived\u003e class Base { public: void interface() { // ... common pre-processing ... // Call to the derived class's implementation static_cast\u003cDerived*\u003e(this)-\u003eimplementation(); // ... common post-processing ... } }; class Derived : public Base\u003cDerived\u003e { public: void implementation() { // Specific implementation } }; Explicit Object Parameter in C++23 Thanks to the explicit object parameter (Deducing this), the C and the R can be removed from the CRTP acronym:\nC++23â€™s explicit object parameter feature allows the class name to be referenced explicitly in the parameter lists of non-static member functions. With Deducing this, the type of the explicit object parameter can be deduced to the derived type and perfectly forwarded. As a result, template non-static member functions can access the derived class, eliminating the need to specialize the object over the derived class.\nCode Example class Base { public: template\u003ctypename T\u003e void interface(this T\u0026\u0026 self) { // ... common pre-processing ... // Call to the derived class's implementation self.implementation(); // ... common post-processing ... } }; class Derived : public Base { public: void implementation() { // Specific implementation } }; Reference https://www.modernescpp.com/index.php/c23-syntactic-sugar-with-deducing-this/\nhttps://www.youtube.com/watch?v=xpomlTd41hg\u0026list=PL6NrtSSUk9t9M_Rk-6YkW9u5RJym-SuWZ\u0026index=1\u0026t=2626s\n","wordCount":"768","inLanguage":"en","datePublished":"2024-01-24T09:33:57+08:00","dateModified":"2024-01-24T09:33:57+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Non-Virtual Polymorphism</h1><div class=post-meta><span title='2024-01-24 09:33:57 +0800 HKT'>January 24, 2024</span>&nbsp;Â·&nbsp;768 words&nbsp;Â·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#modern-features-in-c17>Modern Features in C++17</a></li><li><a href=#code-example>Code Example</a><ul><li><a href=#stdany>std::any</a></li><li><a href=#stdvariant>std::variant</a></li><li><a href=#stdtupple>std::tupple</a></li></ul></li><li><a href=#crtp-in-c98>CRTP in C++98</a><ul><li><a href=#code-example-1>Code Example</a></li></ul></li><li><a href=#explicit-object-parameter-in-c23>Explicit Object Parameter in C++23</a><ul><li><a href=#code-example-2>Code Example</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h2 id=modern-features-in-c17>Modern Features in C++17<a hidden class=anchor aria-hidden=true href=#modern-features-in-c17>#</a></h2><p>Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features <code>std::any</code> and <code>std::variant</code> as described in the table below.</p><p>Notice <code>std::tuple</code> is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to <code>std::any</code> and <code>std::variant</code>.</p><table><thead><tr><th>Feature</th><th>Paired With</th><th>Purpose</th><th>Use Case</th><th>Special Notes</th></tr></thead><tbody><tr><td><code>std::any</code></td><td><code>std::any_cast</code></td><td>To store an instance of any type and safely retrieve the stored value.</td><td>Use <code>std::any</code> when the exact type is unknown or may change, and <code>std::any_cast</code> for retrieval.</td><td>Type-safe storage for single values. <code>std::any_cast</code> throws an exception if the cast is to the wrong type.</td></tr><tr><td><code>std::variant</code></td><td><code>std::visit</code></td><td>To store one of several predefined types and apply a function to the variant&rsquo;s content.</td><td>Use <code>std::variant</code> when the value can be one of a few known types and <code>std::visit</code> for operations.</td><td>Type-safe and more constrained than <code>std::any</code>. <code>std::visit</code> requires a callable applicable to all types in the variant.</td></tr><tr><td><code>std::tuple</code></td><td><code>std::apply</code></td><td>To store a fixed-size collection of heterogeneous values and apply a function to them.</td><td>Use <code>std::tuple</code> for grouping known types and <code>std::apply</code> to call a function with tuple elements.</td><td>Accessed by index using <code>std::get</code>. <code>std::apply</code> useful for calling a function with tuple elements as arguments.</td></tr></tbody></table><h2 id=code-example>Code Example<a hidden class=anchor aria-hidden=true href=#code-example>#</a></h2><h3 id=stdany>std::any<a hidden class=anchor aria-hidden=true href=#stdany>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;any&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>any</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// Store an int
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>any_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// Extract the int
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>);</span> <span class=c1>// Store a string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>any_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// Extract the string
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=stdvariant>std::variant<a hidden class=anchor aria-hidden=true href=#stdvariant>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;variant&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// A variant that can hold either an int, double, or string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>variant</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// Assigning an integer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Visit the variant and apply a lambda function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>visit</span><span class=p>([](</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>arg</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=o>=</span> <span class=s>&#34;Hello, World!&#34;</span><span class=p>;</span> <span class=c1>// Now assign a string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Visit the variant again
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>visit</span><span class=p>([](</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>arg</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=n>var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=stdtupple>std::tupple<a hidden class=anchor aria-hidden=true href=#stdtupple>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;tuple&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// A function to be applied to a tuple
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>,</span> <span class=kt>double</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>t</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=mf>3.14</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Apply the function &#39;print&#39; to the tuple &#39;t&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>apply</span><span class=p>(</span><span class=n>print</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=crtp-in-c98>CRTP in C++98<a hidden class=anchor aria-hidden=true href=#crtp-in-c98>#</a></h2><p>The Curiously Recurring Template Pattern (CRTP) is an advanced C++ idiom that involves a particular form of inheritance that leverages <strong>templates</strong>. It achieves static polymorphism, which allows for polymorphic behavior without the overhead of dynamic polymorphism (such as virtual functions).</p><p>In CRTP, a template class named <code>Base</code> is designed to take a derived class as its template parameter. When defining a derived class, such as <code>Derived</code>, it inherits from <code>Base</code> by passing itself as the template argument (<code>Base&lt;Derived></code>). This allows <code>Base</code> to define an interface which Derived implements, enabling <code>Base</code> to invoke these methods directly.</p><p>The CRTP enables static (compile-time) polymorphism. By using templates, the base class can call methods of the derived class without needing virtual functions. This is because the base class knows the type of the derived class at compile time.</p><p>Unlike dynamic polymorphism, which uses virtual functions to resolve method calls at runtime, CRTP resolves them at compile time. This eliminates the overhead associated with dynamic dispatch (like v-table lookups).</p><h3 id=code-example-1>Code Example<a hidden class=anchor aria-hidden=true href=#code-example-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>interface</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... common pre-processing ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// Call to the derived class&#39;s implementation
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>implementation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ... common post-processing ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>implementation</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Specific implementation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=explicit-object-parameter-in-c23>Explicit Object Parameter in C++23<a hidden class=anchor aria-hidden=true href=#explicit-object-parameter-in-c23>#</a></h2><p>Thanks to the explicit object parameter (<code>Deducing this</code>), the C and the R can be removed from the CRTP acronym:</p><p>C++23&rsquo;s <strong>explicit object parameter</strong> feature allows the class name to be referenced explicitly in the parameter lists of non-static member functions. With <code>Deducing this</code>, the type of the explicit object parameter can be deduced to the derived type and perfectly forwarded. As a result, template non-static member functions can access the derived class, eliminating the need to specialize the object over the derived class.</p><h3 id=code-example-2>Code Example<a hidden class=anchor aria-hidden=true href=#code-example-2>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>interface</span><span class=p>(</span><span class=k>this</span> <span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>self</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... common pre-processing ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// Call to the derived class&#39;s implementation
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>self</span><span class=p>.</span><span class=n>implementation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ... common post-processing ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>implementation</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Specific implementation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=https://www.modernescpp.com/index.php/c23-syntactic-sugar-with-deducing-this/>https://www.modernescpp.com/index.php/c23-syntactic-sugar-with-deducing-this/</a></p><p><a href="https://www.youtube.com/watch?v=xpomlTd41hg&amp;list=PL6NrtSSUk9t9M_Rk-6YkW9u5RJym-SuWZ&amp;index=1&amp;t=2626s">https://www.youtube.com/watch?v=xpomlTd41hg&amp;list=PL6NrtSSUk9t9M_Rk-6YkW9u5RJym-SuWZ&amp;index=1&amp;t=2626s</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>