<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>`constexpr` from the perspective of assembly code | Yac's Log</title><meta name=keywords content="C++"><meta name=description content="constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.
However, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.
Code with constexpr #include <stddef.h> #include <string_view> #include <algorithm> #include <cstdio> template<size_t N> class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits<char>::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template<size_t N> constexpr auto make_fixed_string(const char (&amp;str)[N]) { return FixedString<N>{str}; } constexpr const static FixedString<50> x{&#34;Hello, embedded World!"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2024-12-24-constexpr-assembly/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="`constexpr` from the perspective of assembly code"><meta property="og:description" content="constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.
However, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.
Code with constexpr #include <stddef.h> #include <string_view> #include <algorithm> #include <cstdio> template<size_t N> class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits<char>::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template<size_t N> constexpr auto make_fixed_string(const char (&amp;str)[N]) { return FixedString<N>{str}; } constexpr const static FixedString<50> x{&#34;Hello, embedded World!"><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2024-12-24-constexpr-assembly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-24T10:58:30+08:00"><meta property="article:modified_time" content="2024-12-24T10:58:30+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="`constexpr` from the perspective of assembly code"><meta name=twitter:description content="constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.
However, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.
Code with constexpr #include <stddef.h> #include <string_view> #include <algorithm> #include <cstdio> template<size_t N> class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits<char>::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template<size_t N> constexpr auto make_fixed_string(const char (&amp;str)[N]) { return FixedString<N>{str}; } constexpr const static FixedString<50> x{&#34;Hello, embedded World!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"`constexpr` from the perspective of assembly code","item":"https://yuang-chen.github.io/posts/2024-12-24-constexpr-assembly/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"`constexpr` from the perspective of assembly code","name":"\u0060constexpr\u0060 from the perspective of assembly code","description":"constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.\nHowever, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.\nCode with constexpr #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; template\u0026lt;size_t N\u0026gt; class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits\u0026lt;char\u0026gt;::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template\u0026lt;size_t N\u0026gt; constexpr auto make_fixed_string(const char (\u0026amp;str)[N]) { return FixedString\u0026lt;N\u0026gt;{str}; } constexpr const static FixedString\u0026lt;50\u0026gt; x{\u0026#34;Hello, embedded World!","keywords":["C++"],"articleBody":"constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.\nHowever, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.\nCode with constexpr #include #include #include #include template\u003csize_t N\u003e class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits\u003cchar\u003e::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template\u003csize_t N\u003e constexpr auto make_fixed_string(const char (\u0026str)[N]) { return FixedString\u003cN\u003e{str}; } constexpr const static FixedString\u003c50\u003e x{\"Hello, embedded World!\"}; constexpr const static auto y = make_fixed_string(\"Hello, some other planet!\"); int main () { printf(\"x: %s, %lu\\n\", x.string_view().data(), sizeof(x)); printf(\"y: %s, %lu\\n\", y.string_view().data(), sizeof(y)); } Assembly Code with constexpr With constexpr, the compiler will optimize the code at compile time, resulting in the 20-line assembly code.\nNotably, the code uses .rodata exclusively (read-only data section) for accessing string literals and constant values. The data in this section does not change during execution, and it’s typically stored in a more optimized manner by the operating system (e.g., the OS may map it as read-only and store it in shared memory).\nCode without constexpr Just delete the constexpr keyword from the code, we obtain the 50-line assembly code, leading to larger binary size (code bloat). It differs from the prior assembly code in two aspects: Data Section Usage and Global Static Initialization\nData Section Usage: The code relies on .rodata and .bss sections for storing and accessing variables. The .bss is used for uninitialized data, meaning the program will need to write to these locations at runtime. Hence, the program would experience higher memory initialization overhead and possible cache inefficiencies. Global Static Initialization: The code uses _GLOBAL__sub_I_main to initialize global static variables, which is executed before main() runs. Therefore, the program is slower to start. ","wordCount":"353","inLanguage":"en","datePublished":"2024-12-24T10:58:30+08:00","dateModified":"2024-12-24T10:58:30+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2024-12-24-constexpr-assembly/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>`constexpr` from the perspective of assembly code</h1><div class=post-meta><span title='2024-12-24 10:58:30 +0800 CST'>December 24, 2024</span>&nbsp;·&nbsp;353 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p><code>constexpr</code> is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.</p><p>However, I mainly use it for <code>type</code>-related operations. I seldom apply it to <code>data</code>-related tasks, since defining data with <code>constexpr</code> requires constant values, which is rarely feasible in my projects.</p><h3 id=code-with-constexpr>Code with <code>constexpr</code><a hidden class=anchor aria-hidden=true href=#code-with-constexpr>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stddef.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string_view&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>size_t</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FixedString</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>mSize</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>mData</span><span class=p>[</span><span class=n>N</span><span class=p>]{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>FixedString</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Constructor that computes string length at compile time
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>constexpr</span> <span class=nf>FixedString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span> <span class=o>:</span> <span class=n>mSize</span><span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;::</span><span class=n>length</span><span class=p>(</span><span class=n>str</span><span class=p>)}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>copy_n</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>size</span><span class=p>(),</span> <span class=n>mData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>mSize</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=n>string_view</span> <span class=n>string_view</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>{</span><span class=n>mData</span><span class=p>,</span> <span class=n>mSize</span><span class=p>};</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>size_t</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>auto</span>  <span class=n>make_fixed_string</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>str</span><span class=p>)[</span><span class=n>N</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>FixedString</span><span class=o>&lt;</span><span class=n>N</span><span class=o>&gt;</span><span class=p>{</span><span class=n>str</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>const</span> <span class=k>static</span> <span class=n>FixedString</span><span class=o>&lt;</span><span class=mi>50</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>{</span><span class=s>&#34;Hello, embedded World!&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=k>const</span> <span class=k>static</span> <span class=k>auto</span> <span class=n>y</span> <span class=o>=</span> <span class=n>make_fixed_string</span><span class=p>(</span><span class=s>&#34;Hello, some other planet!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;x: %s, %lu</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>x</span><span class=p>.</span><span class=n>string_view</span><span class=p>().</span><span class=n>data</span><span class=p>(),</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>x</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;y: %s, %lu</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>y</span><span class=p>.</span><span class=n>string_view</span><span class=p>().</span><span class=n>data</span><span class=p>(),</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=assembly-code-with-constexpr>Assembly Code with <code>constexpr</code><a hidden class=anchor aria-hidden=true href=#assembly-code-with-constexpr>#</a></h4><p>With <code>constexpr</code>, the compiler will optimize the code at compile time, resulting in the 20-line assembly <a href=assembly-w-constexpr.asm>code</a>.</p><p>Notably, the code uses <code>.rodata</code> exclusively (read-only data section) for accessing string literals and constant values. The data in this section does not change during execution, and it&rsquo;s typically stored in a more optimized manner by the operating system (e.g., the OS may map it as read-only and store it in shared memory).</p><h4 id=code-without-constexpr>Code without <code>constexpr</code><a hidden class=anchor aria-hidden=true href=#code-without-constexpr>#</a></h4><p>Just delete the <code>constexpr</code> keyword from the code, we obtain the 50-line assembly <a href=assembly-wo-constexpr.asm>code</a>, leading to larger binary size (code bloat). It differs from the prior assembly code in two aspects: <strong>Data Section Usage</strong> and <strong>Global Static Initialization</strong></p><ul><li><strong>Data Section Usage</strong>: The code relies on <code>.rodata</code> and <code>.bss</code> sections for storing and accessing variables. The <code>.bss</code> is used for uninitialized data, meaning the program will need to <em>write</em> to these locations at runtime. Hence, the program would experience higher memory initialization overhead and possible cache inefficiencies.</li><li><strong>Global Static Initialization</strong>: The code uses <code>_GLOBAL__sub_I_main</code> to initialize global static variables, which is executed before <code>main()</code> runs. Therefore, the program is slower to start.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/c++/>C++</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>