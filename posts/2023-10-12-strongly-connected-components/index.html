<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Strongly Connected Components | Yac's Log</title><meta name=keywords content="Graph"><meta name=description content="Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.
Weakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the &ldquo;default&rdquo; CC algorithm, if there isn&rsquo;t a specification for Strongly or Weakly.
Kosaraju&rsquo;s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Strongly Connected Components"><meta property="og:description" content="Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.
Weakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the &ldquo;default&rdquo; CC algorithm, if there isn&rsquo;t a specification for Strongly or Weakly.
Kosaraju&rsquo;s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-12T11:54:29+08:00"><meta property="article:modified_time" content="2023-10-12T11:54:29+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Strongly Connected Components"><meta name=twitter:description content="Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.
Weakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the &ldquo;default&rdquo; CC algorithm, if there isn&rsquo;t a specification for Strongly or Weakly.
Kosaraju&rsquo;s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Strongly Connected Components","item":"https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Strongly Connected Components","name":"Strongly Connected Components","description":"Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.\nWeakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the \u0026ldquo;default\u0026rdquo; CC algorithm, if there isn\u0026rsquo;t a specification for Strongly or Weakly.\nKosaraju\u0026rsquo;s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC.","keywords":["Graph"],"articleBody":"Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.\nWeakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the “default” CC algorithm, if there isn’t a specification for Strongly or Weakly.\nKosaraju’s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC. Reverse Post-Order ensures that, in the second pass, every vertex is processed before any of its dependent vertices.\nTarjan’s Algorithm: Run DFS while maintaining the stack of DFS tree, the pre-order of nodes and low-link values. Find Back-Edge, and update low-link values based on traversed children. [Backtracking] if a vertex has a low-link value equal to its ID, pop the stack to form an SCC. Summary Feature Kosaraju’s Algorithm Tarjan’s Algorithm Time Complexity O(V + E) O(V + E) Space Complexity O(V) O(V) DFS Traversals Two One Graph Representations Needs both original and transposed graph Doesn’t need a transposed graph Backtracking 2nd DFS SCC construction Both algorithms employ DFS (alternatively, BFS for parallel implementations) and recorder the traversing order, alongside backtracking to determine the SCC. When utilizing DFS with backtracking, a stack is always used to keep track of the DFS tree.\nCode #include #include #include #include auto Kosaraju(const std::vector\u003cint\u003e\u0026 csr_pointer, const std::vector\u003cint\u003e\u0026 csr_index, const std::vector\u003cint\u003e\u0026 csc_pointer, const std::vector\u003cint\u003e\u0026 csc_index) { const auto num_nodes = csr_pointer.size() - 1; std::vector\u003cbool\u003e visited(num_nodes, false); std::stack\u003cint\u003e post_order_stack; //! First DFS // traverse CSR graph std::function\u003cvoid(int)\u003e dfs_1st = [\u0026](int source) { visited[source] = true; for(auto i = csr_pointer[source]; i \u003c csr_pointer[source + 1]; i++) { auto target = csr_index[i]; if(!visited[target]) { dfs_1st(target); } } post_order_stack.push(source); }; for(int i = 0; i \u003c num_nodes; i++) { if(!visited[i]) { dfs_1st(i); } } //! Second DFS std::function\u003cvoid(int, std::vector\u003cint\u003e\u0026)\u003e dfs_2nd = [\u0026](int target, std::vector\u003cint\u003e\u0026 SCC) { visited[target] = false; SCC.push_back(target); for(auto i = csc_pointer[target]; i \u003c csc_pointer[target + 1]; i++) { auto source = csc_index[i]; if(visited[source]) { dfs_2nd(source, SCC); } } }; // traverse CSC graph -- backtracking std::vector\u003cstd::vector\u003cint\u003e\u003e all_SCCs; while(!post_order_stack.empty()) { auto node = post_order_stack.top(); post_order_stack.pop(); if(visited[node]) // go through the visited nodes { std::vector\u003cint\u003e SCC; dfs_2nd(node, SCC); all_SCCs.push_back(SCC); } } return all_SCCs; } auto Tarjan(const std::vector\u003cint\u003e\u0026 csr_pointer, const std::vector\u003cint\u003e\u0026 csr_index) { auto num_nodes = csr_pointer.size() - 1; // The depth-first search order in which the vertices are discovered std::vector\u003cint\u003e pre_order(num_nodes, -1); // This represents the smallest pre_order value reachable from vertex [i] std::vector\u003cint\u003e low_link(num_nodes, 0); std::vector\u003cbool\u003e in_stack(num_nodes, false); std::stack\u003cint\u003e dfs_tree_stack; std::vector\u003cstd::vector\u003cint\u003e\u003e all_SCCs; std::function\u003cvoid(int, int, std::vector\u003cint\u003e\u0026, std::vector\u003cint\u003e\u0026, std::vector\u003cbool\u003e\u0026, std::stack\u003cint\u003e\u0026, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026)\u003e dfs = [\u0026csr_pointer, \u0026csr_index, \u0026dfs](int source, int count, std::vector\u003cint\u003e\u0026 pre_order, std::vector\u003cint\u003e\u0026 low_link, std::vector\u003cbool\u003e\u0026 in_stack, std::stack\u003cint\u003e\u0026 dfs_tree_stack, std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 all_SCCs) { pre_order[source] = count++; low_link[source] = pre_order[source]; in_stack[source] = true; dfs_tree_stack.push(source); // Back Edge: A back edge is an edge that connects a vertex to one of its ancestors in the DFS tree, creating a cycle. for(auto i = csr_pointer[source]; i \u003c csr_pointer[source + 1]; i++) { auto target = csr_index[i]; // if target is unvisited, perform DFS if(pre_order[target] == -1) { dfs(target, count, pre_order, low_link, in_stack, dfs_tree_stack, all_SCCs); } // When a back edge from \"source\" to \"target\" is encountered and \"target\" is still in the stack, // low_link[source] is updated to min(low_link[source], dfn[target]). This is because \"target\" is an ancestor // of \"source\" in the DFS tree. The update indicates that there is a way to reach back to \"target\" // from \"source,\" thereby forming a cycle. if(in_stack[target]) { low_link[source] = std::min(low_link[source], low_link[target]); } } // \u003e\u003e Backtracking, after visiting a root vertex and all its descendants, // check if current vertex is the root vertex // if true, the DFS tree is a SCC if(pre_order[source] == low_link[source]) { std::vector\u003cint\u003e scc; while(true) { auto node = dfs_tree_stack.top(); dfs_tree_stack.pop(); in_stack[node] = false; scc.push_back(node); if(node == source) { break; } } all_SCCs.push_back(scc); } }; for(int i = 0; i \u003c num_nodes; i++) { if(pre_order[i] == -1) { dfs(i, 0, pre_order, low_link, in_stack, dfs_tree_stack, all_SCCs); } } return all_SCCs; } int main() { // CSR representation for the graph std::vector\u003cint\u003e csr_pointer = { 0, 2, 3, 4, 5, 6 }; std::vector\u003cint\u003e csr_index = { 1, 3, 2, 0, 4, 3 }; // CSC representation for the transpose of the graph std::vector\u003cint\u003e csc_pointer = { 0, 1, 2, 3, 5, 6 }; std::vector\u003cint\u003e csc_index = { 2, 0, 1, 0, 4, 3 }; auto all_SCCs = Kosaraju2(csr_pointer, csr_index, csc_pointer, csc_index); for(const auto\u0026 scc : all_SCCs) { std::cout \u003c\u003c \"SCC: \"; for(int vertex : scc) { std::cout \u003c\u003c vertex \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } std::cout \u003c\u003c \"------------------\" \u003c\u003c std::endl; all_SCCs = Tarjan(csr_pointer, csr_index); for(const auto\u0026 scc : all_SCCs) { std::cout \u003c\u003c \"SCC: \"; for(int vertex : scc) { std::cout \u003c\u003c vertex \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } return 0; } ","wordCount":"820","inLanguage":"en","datePublished":"2023-10-12T11:54:29+08:00","dateModified":"2023-10-12T11:54:29+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Strongly Connected Components</h1><div class=post-meta><span title='2023-10-12 11:54:29 +0800 CST'>October 12, 2023</span>&nbsp;·&nbsp;820 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h1><p><em>Strongly</em> Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.</p><p><em>Weakly</em> Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the &ldquo;default&rdquo; CC algorithm, if there isn&rsquo;t a specification for Strongly or Weakly.</p><h3 id=kosarajus-algorithm><strong>Kosaraju&rsquo;s Algorithm:</strong><a hidden class=anchor aria-hidden=true href=#kosarajus-algorithm>#</a></h3><ol><li>Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS).</li><li>[Backtracking] Run 2nd DFS on the <em>transposed</em> graph, starting with the visited vertices in <strong><strong>Reverse Post-Order</strong></strong></li><li>Each DFS tree in step 2 is an SCC.</li></ol><p>Reverse Post-Order ensures that, in the second pass, every vertex is processed before any of its dependent vertices.</p><h3 id=tarjans-algorithm><strong>Tarjan&rsquo;s Algorithm:</strong><a hidden class=anchor aria-hidden=true href=#tarjans-algorithm>#</a></h3><ol><li>Run DFS while maintaining the stack of DFS tree, the pre-order of nodes and low-link values.</li><li>Find Back-Edge, and update low-link values based on traversed children.</li><li>[Backtracking] if a vertex has a low-link value equal to its ID, pop the stack to form an SCC.</li></ol><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><table><thead><tr><th>Feature</th><th>Kosaraju&rsquo;s Algorithm</th><th>Tarjan&rsquo;s Algorithm</th></tr></thead><tbody><tr><td>Time Complexity</td><td>O(V + E)</td><td>O(V + E)</td></tr><tr><td>Space Complexity</td><td>O(V)</td><td>O(V)</td></tr><tr><td>DFS Traversals</td><td>Two</td><td>One</td></tr><tr><td>Graph Representations</td><td>Needs both original and transposed graph</td><td>Doesn&rsquo;t need a transposed graph</td></tr><tr><td>Backtracking</td><td>2nd DFS</td><td>SCC construction</td></tr></tbody></table><p>Both algorithms employ DFS (alternatively, BFS for parallel implementations) and recorder the traversing order, alongside backtracking to determine the SCC. When utilizing DFS with backtracking, a stack is always used to keep track of the DFS tree.</p><h1 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stack&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>Kosaraju</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csr_pointer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csr_index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csc_pointer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csc_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=k>auto</span>        <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>csr_pointer</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>visited</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>post_order_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//! First DFS
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// traverse CSR graph
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>dfs_1st</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>source</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=n>csr_pointer</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>csr_pointer</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>target</span> <span class=o>=</span> <span class=n>csr_index</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>target</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs_1st</span><span class=p>(</span><span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>post_order_stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_nodes</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs_1st</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//! Second DFS
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>dfs_2nd</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>target</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>SCC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SCC</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=n>csc_pointer</span><span class=p>[</span><span class=n>target</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>csc_pointer</span><span class=p>[</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>source</span> <span class=o>=</span> <span class=n>csc_index</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>source</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs_2nd</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>SCC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=c1>// traverse CSC graph -- backtracking
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>all_SCCs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>post_order_stack</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>node</span> <span class=o>=</span> <span class=n>post_order_stack</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>post_order_stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>])</span> <span class=c1>// go through the visited nodes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>SCC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs_2nd</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>SCC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>all_SCCs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>SCC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>all_SCCs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>Tarjan</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csr_pointer</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>csr_index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>csr_pointer</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// The depth-first search order in which the vertices are discovered
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pre_order</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>  <span class=c1>//  This represents the smallest pre_order value reachable from vertex [i]
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>low_link</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>in_stack</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dfs_tree_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>all_SCCs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=kt>int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;&amp;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&amp;</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>csr_pointer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>csr_index</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dfs</span><span class=p>](</span><span class=kt>int</span> <span class=n>source</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=kt>int</span> <span class=n>count</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>pre_order</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>low_link</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;&amp;</span> <span class=n>in_stack</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>dfs_tree_stack</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&amp;</span> <span class=n>all_SCCs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>pre_order</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>low_link</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>pre_order</span><span class=p>[</span><span class=n>source</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>in_stack</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs_tree_stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Back Edge: A back edge is an edge that connects a vertex to one of its ancestors in the DFS tree, creating a cycle.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=n>csr_pointer</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>csr_pointer</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>target</span> <span class=o>=</span> <span class=n>csr_index</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if target is unvisited, perform DFS
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>pre_order</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>dfs</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>pre_order</span><span class=p>,</span> <span class=n>low_link</span><span class=p>,</span> <span class=n>in_stack</span><span class=p>,</span> <span class=n>dfs_tree_stack</span><span class=p>,</span> <span class=n>all_SCCs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// When a back edge from &#34;source&#34; to &#34;target&#34; is encountered and &#34;target&#34; is still in the stack,
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// low_link[source] is updated to min(low_link[source], dfn[target]). This is because &#34;target&#34; is an ancestor
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// of &#34;source&#34; in the DFS tree. The update indicates that there is a way to reach back to &#34;target&#34; 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// from &#34;source,&#34; thereby forming a cycle.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>in_stack</span><span class=p>[</span><span class=n>target</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>low_link</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>low_link</span><span class=p>[</span><span class=n>source</span><span class=p>],</span> <span class=n>low_link</span><span class=p>[</span><span class=n>target</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=c1>// &gt;&gt; Backtracking, after visiting a root vertex and all its descendants, 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// check if current vertex is the root vertex
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// if true, the DFS tree is a SCC 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span><span class=p>(</span><span class=n>pre_order</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>==</span> <span class=n>low_link</span><span class=p>[</span><span class=n>source</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>scc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>auto</span> <span class=n>node</span> <span class=o>=</span> <span class=n>dfs_tree_stack</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>          <span class=n>dfs_tree_stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>          <span class=n>in_stack</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>scc</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=k>if</span><span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=n>source</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>all_SCCs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>scc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_nodes</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pre_order</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>dfs</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>pre_order</span><span class=p>,</span> <span class=n>low_link</span><span class=p>,</span> <span class=n>in_stack</span><span class=p>,</span> <span class=n>dfs_tree_stack</span><span class=p>,</span> <span class=n>all_SCCs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>all_SCCs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// CSR representation for the graph
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>csr_pointer</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>csr_index</span>   <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// CSC representation for the transpose of the graph
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>csc_pointer</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>csc_index</span>   <span class=o>=</span> <span class=p>{</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>all_SCCs</span> <span class=o>=</span> <span class=n>Kosaraju2</span><span class=p>(</span><span class=n>csr_pointer</span><span class=p>,</span> <span class=n>csr_index</span><span class=p>,</span> <span class=n>csc_pointer</span><span class=p>,</span> <span class=n>csc_index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>scc</span> <span class=p>:</span> <span class=n>all_SCCs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;SCC: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=nl>vertex</span> <span class=p>:</span> <span class=n>scc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>vertex</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;------------------&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>all_SCCs</span> <span class=o>=</span> <span class=n>Tarjan</span><span class=p>(</span><span class=n>csr_pointer</span><span class=p>,</span> <span class=n>csr_index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>scc</span> <span class=p>:</span> <span class=n>all_SCCs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;SCC: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=nl>vertex</span> <span class=p>:</span> <span class=n>scc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>vertex</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/graph/>Graph</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>