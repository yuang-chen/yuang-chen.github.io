<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Biconnected Components | Yac's Log</title><meta name=keywords content><meta name=description content="Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.
Strict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Biconnected Components"><meta property="og:description" content="Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.
Strict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-20T10:43:56+08:00"><meta property="article:modified_time" content="2023-11-20T10:43:56+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Biconnected Components"><meta name=twitter:description content="Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.
Strict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Biconnected Components","item":"https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Biconnected Components","name":"Biconnected Components","description":"Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.\nStrict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component.","keywords":[],"articleBody":"Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.\nStrict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component.\nIn practical implementations:\nComputational Interpretation: An edge connecting two vertices (without forming part of a larger cycle) is sometimes considered a trivial BCC for completeness in algorithms. This interpretation is adopted for simplicity and ensures that all edges are included in the identification of BCCs.\nBCC vs SCC The concepts of Biconnected Components (BCCs) and Strongly Connected Components (SCCs) are fundamentally different, and thus the algorithms to find them differ significantly. Both concepts are related to graph theory but apply to different types of graphs and have different implications.\nAspect Strongly Connected Components (SCCs) Biconnected Components (BCCs) Graph Type Directed Graphs Undirected Graphs Definition A maximal subset of vertices where for every pair ( U ) and ( V ), there is a directed path from ( U ) to ( V ) and from ( V ) to ( U ). A maximal subgraph where the removal of any single vertex does not disconnect the rest of the subgraph. Involves cycles or edges. Key Focus Vertex connectivity considering directionality Edge connectivity without considering directionality Typical Algorithms Kosaraju’s, Tarjan’s, Gabow’s algorithms Tarjan’s algorithm for articulation points and bridges Applications Detecting cycles, strong relationships in directed networks like web pages, social networks Network reliability, circuit design, understanding the resilience of networks to node failure Code #include #include #include std::vector\u003cstd::vector\u003cint\u003e\u003e tarjan(int num_vertices, const std::vector\u003cint\u003e\u0026 row_ptr, const std::vector\u003cint\u003e\u0026 col_idx) { std::vector\u003cint\u003e discovery_time(num_vertices, -1), low_time(num_vertices, -1), parent(num_vertices, -1); std::vector\u003cbool\u003e visited(num_vertices, false); std::stack\u003cint\u003e stack; std::vector\u003cstd::vector\u003cint\u003e\u003e bcc; int time = 0; auto dfs = [\u0026](int source, auto\u0026\u0026 dfs_ref) -\u003e void { discovery_time[source] = low_time[source] = time++; visited[source] = true; stack.push(source); for (int i = row_ptr[source]; i \u003c row_ptr[source + 1]; ++i) { int target = col_idx[i]; if (!visited[target]) { parent[target] = source; dfs_ref(target, dfs_ref); low_time[source] = std::min(low_time[source], low_time[target]); if (low_time[target] \u003e= discovery_time[source]) { std::vector\u003cint\u003e component; while (stack.top() != target) { component.push_back(stack.top()); stack.pop(); } component.push_back(target); stack.pop(); component.push_back(source); bcc.push_back(component); } } else if (target != parent[source]) { low_time[source] = std::min(low_time[source], discovery_time[target]); } } }; for (int i = 0; i \u003c num_vertices; ++i) { if (!visited[i]) { dfs(i, dfs); if (!stack.empty()) { std::vector\u003cint\u003e component; while (!stack.empty()) { component.push_back(stack.top()); stack.pop(); } bcc.push_back(component); } } } return bcc; } int main() { int num_vertices = 6; std::vector\u003cint\u003e row_ptr = {0, 2, 4, 7, 10, 12, 14}; std::vector\u003cint\u003e col_idx = {1, 2, 0, 2, 0, 1, 3, 2, 4, 5, 3, 5, 3, 4}; auto bccs = tarjan(num_vertices, row_ptr, col_idx); // Print the BCCs for (const auto\u0026 component : bccs) { std::cout \u003c\u003c \"BCC: \"; for (int v : component) { std::cout \u003c\u003c v \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; } return 0; } ","wordCount":"512","inLanguage":"en","datePublished":"2023-11-20T10:43:56+08:00","dateModified":"2023-11-20T10:43:56+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Biconnected Components</h1><div class=post-meta><span title='2023-11-20 10:43:56 +0800 HKT'>November 20, 2023</span>&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=note>Note<a hidden class=anchor aria-hidden=true href=#note>#</a></h1><p>Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.</p><p><strong>Strict Definition</strong>: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component.</p><p>In practical implementations:</p><p><strong>Computational Interpretation</strong>: An edge connecting two vertices (without forming part of a larger cycle) is sometimes considered a trivial BCC for completeness in algorithms. This interpretation is adopted for simplicity and ensures that all edges are included in the identification of BCCs.</p><h1 id=bcc-vs-scc>BCC vs SCC<a hidden class=anchor aria-hidden=true href=#bcc-vs-scc>#</a></h1><p>The concepts of Biconnected Components (BCCs) and Strongly Connected Components (SCCs) are fundamentally different, and thus the algorithms to find them differ significantly. Both concepts are related to graph theory but apply to different types of graphs and have different implications.</p><table><thead><tr><th>Aspect</th><th>Strongly Connected Components (SCCs)</th><th>Biconnected Components (BCCs)</th></tr></thead><tbody><tr><td><strong>Graph Type</strong></td><td>Directed Graphs</td><td>Undirected Graphs</td></tr><tr><td><strong>Definition</strong></td><td>A maximal subset of vertices where for every pair ( U ) and ( V ), there is a directed path from ( U ) to ( V ) and from ( V ) to ( U ).</td><td>A maximal subgraph where the removal of any single vertex does not disconnect the rest of the subgraph. Involves cycles or edges.</td></tr><tr><td><strong>Key Focus</strong></td><td>Vertex connectivity considering directionality</td><td>Edge connectivity without considering directionality</td></tr><tr><td><strong>Typical Algorithms</strong></td><td>Kosaraju&rsquo;s, Tarjan&rsquo;s, Gabow&rsquo;s algorithms</td><td>Tarjan&rsquo;s algorithm for articulation points and bridges</td></tr><tr><td><strong>Applications</strong></td><td>Detecting cycles, strong relationships in directed networks like web pages, social networks</td><td>Network reliability, circuit design, understanding the resilience of networks to node failure</td></tr></tbody></table><h1 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stack&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>tarjan</span><span class=p>(</span><span class=kt>int</span> <span class=n>num_vertices</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>row_ptr</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>col_idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>discovery_time</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=n>low_time</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=n>parent</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>visited</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>bcc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>time</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>dfs</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>source</span><span class=p>,</span> <span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>dfs_ref</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>discovery_time</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>low_time</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>time</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>row_ptr</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>target</span> <span class=o>=</span> <span class=n>col_idx</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>target</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>parent</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>source</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>dfs_ref</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>dfs_ref</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>low_time</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>low_time</span><span class=p>[</span><span class=n>source</span><span class=p>],</span> <span class=n>low_time</span><span class=p>[</span><span class=n>target</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>low_time</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>discovery_time</span><span class=p>[</span><span class=n>source</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>component</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>while</span> <span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=n>top</span><span class=p>()</span> <span class=o>!=</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=n>top</span><span class=p>());</span>
</span></span><span class=line><span class=cl>                        <span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>bcc</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>component</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>target</span> <span class=o>!=</span> <span class=n>parent</span><span class=p>[</span><span class=n>source</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>low_time</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>low_time</span><span class=p>[</span><span class=n>source</span><span class=p>],</span> <span class=n>discovery_time</span><span class=p>[</span><span class=n>target</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_vertices</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>dfs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>component</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>component</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=n>top</span><span class=p>());</span>
</span></span><span class=line><span class=cl>                    <span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>bcc</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>component</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>bcc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num_vertices</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>row_ptr</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>14</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>col_idx</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>bccs</span> <span class=o>=</span> <span class=n>tarjan</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=n>row_ptr</span><span class=p>,</span> <span class=n>col_idx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Print the BCCs
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>component</span> <span class=p>:</span> <span class=n>bccs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;BCC: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>v</span> <span class=p>:</span> <span class=n>component</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>