<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Minimum Spanning Tree | Yac's Log</title><meta name=keywords content="Graphs"><meta name=description content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-09-29-mst/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Minimum Spanning Tree"><meta property="og:description" content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-09-29-mst/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-29T10:00:07+08:00"><meta property="article:modified_time" content="2023-09-29T10:00:07+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Minimum Spanning Tree"><meta name=twitter:description content="Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Minimum Spanning Tree","item":"https://yuang-chen.github.io/posts/2023-09-29-mst/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Minimum Spanning Tree","name":"Minimum Spanning Tree","description":"Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it\u0026rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.","keywords":["Graphs"],"articleBody":"Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it’s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.\nMST, more specifically, Prim’s algorithm, is highly similar to Dijkstra’s algorithm for SSSP. Both use a priory_queue to keep the minimum distance and a visited frontier to avoid redundant traversal. Even the code structure are almost the same as well as time complexity $O((V+E)log(V))$.\nThe key difference lies in the definition, evaluation and calculation of distance.\nPrim’s : distance[target] = weight; In each step, the edge with the smallest weight that connects a vertex in the MST to a vertex outside it is chosen. Consequently, a Minimum Spanning Tree is produced, which is a subgraph that includes all vertices and has (V - 1) edges. Dijkstra’s: distance[target] = distance[curr] + weight; In each step, the vertex with the smallest distance from the root vertex is chosen, and its neighbors are updated. Consequently, a Shortest-Path Tree is produced, which may not include all vertices and edges but will provide the shortest path from the source vertex to all reachable vertices. Code #include #include #include // Prim's algorithm to find the minimum spanning tree auto prim(const std::vector\u003cint\u003e\u0026 row_pointer, const std::vector\u003cint\u003e\u0026 column_index, const std::vector\u003cfloat\u003e\u0026 values) { // the same setting as Dijkstra's SSSP const auto num_nodes = row_pointer.size() - 1; std::vector\u003cfloat\u003e distance(num_nodes, std::numeric_limits\u003cfloat\u003e::max()); std::vector\u003cint\u003e parent(num_nodes, -1); std::vector\u003cbool\u003e visited(num_nodes, false); std::priority_queue\u003c std::pair\u003cfloat, int\u003e, std::vector\u003cstd::pair\u003cfloat, int\u003e\u003e, std::greater\u003cstd::pair\u003cfloat, int\u003e\u003e\u003e min_heap; // start from vertex 0 min_heap.push({ 0.0, 0 }); distance[0] = 0.0; while(!min_heap.empty()) { auto [dist, source] = min_heap.top(); min_heap.pop(); visited[source] = true; // iterate over all outgoing edges for(auto i = row_pointer[source]; i \u003c row_pointer[source + 1]; i++) { auto target = column_index[i]; auto weight = values[i]; if(!visited[target] \u0026\u0026 weight \u003c distance[target]) { distance[target] = weight; parent[target] = source; min_heap.push({ weight, target }); } } } return parent; } int main() { std::vector\u003cint\u003e row_pointer = { 0, 3, 5, 7, 10, 12, 14 }; std::vector\u003cint\u003e column_index = { 1, 2, 3, 0, 2, 0, 1, 0, 4, 5, 3, 5, 3, 4 }; std::vector\u003cfloat\u003e values = { 1.2, 3.4, 0.5, 1.2, 4.1, 3.4, 4.1, 0.5, 2.8, 1.9, 2.8, 4.7, 1.9, 4.7}; auto parent = prim(row_pointer, column_index, values); for(size_t i = 0; i \u003c parent.size(); i++) { std::cout \u003c\u003c parent[i] \u003c\u003c \" \"; } } ","wordCount":"435","inLanguage":"en","datePublished":"2023-09-29T10:00:07+08:00","dateModified":"2023-09-29T10:00:07+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-09-29-mst/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Minimum Spanning Tree</h1><div class=post-meta><span title='2023-09-29 10:00:07 +0800 HKT'>September 29, 2023</span>&nbsp;·&nbsp;435 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h1><p>A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the <em>minimum possible total edge weight</em> among all the trees that can be created from the graph. In simpler terms, it&rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.</p><p>MST, more specifically, Prim&rsquo;s algorithm, is highly similar to Dijkstra&rsquo;s algorithm for SSSP. Both use a <code>priory_queue</code> to keep the minimum distance and a <code>visited</code> frontier to avoid redundant traversal. Even the code structure are almost the same as well as time complexity $O((V+E)log(V))$.</p><p>The key difference lies in the definition, evaluation and calculation of <strong>distance</strong>.</p><ul><li>Prim’s : <code>distance[target] = weight;</code><ul><li>In each step, the <em>edge</em> with the smallest weight that connects a vertex in the MST to a vertex outside it is chosen.</li><li>Consequently, a Minimum Spanning Tree is produced, which is a subgraph that includes all vertices and has <strong><code>(V - 1)</code></strong> edges.</li></ul></li><li>Dijkstra’s: <code>distance[target] = distance[curr] + weight;</code><ul><li>In each step, the <em>vertex</em> with the smallest distance from the <em>root</em> vertex is chosen, and its neighbors are updated.</li><li>Consequently, a Shortest-Path Tree is produced, which may not include all vertices and edges but will provide the shortest path from the source vertex to all reachable vertices.</li></ul></li></ul><h1 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Prim&#39;s algorithm to find the minimum spanning tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>prim</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>row_pointer</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>column_index</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;&amp;</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the same setting as Dijkstra&#39;s SSSP
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=k>auto</span>         <span class=n>num_nodes</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>distance</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>parent</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span>  <span class=n>visited</span><span class=p>(</span><span class=n>num_nodes</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>priority_queue</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>std</span><span class=o>::</span><span class=n>greater</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>float</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;&gt;</span>
</span></span><span class=line><span class=cl>      <span class=n>min_heap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// start from vertex 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>min_heap</span><span class=p>.</span><span class=n>push</span><span class=p>({</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mi>0</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=n>distance</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>min_heap</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=p>[</span><span class=n>dist</span><span class=p>,</span> <span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=n>min_heap</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>min_heap</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>source</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// iterate over all outgoing edges
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>i</span> <span class=o>=</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>source</span><span class=p>];</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>row_pointer</span><span class=p>[</span><span class=n>source</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>target</span> <span class=o>=</span> <span class=n>column_index</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>weight</span> <span class=o>=</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>target</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>target</span><span class=p>]</span>   <span class=o>=</span> <span class=n>source</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>min_heap</span><span class=p>.</span><span class=n>push</span><span class=p>({</span> <span class=n>weight</span><span class=p>,</span> <span class=n>target</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>row_pointer</span>  <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>14</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>   <span class=n>column_index</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>values</span>       <span class=o>=</span> <span class=p>{</span> <span class=mf>1.2</span><span class=p>,</span> <span class=mf>3.4</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>,</span> <span class=mf>4.1</span><span class=p>,</span> <span class=mf>3.4</span><span class=p>,</span> <span class=mf>4.1</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>2.8</span><span class=p>,</span> <span class=mf>1.9</span><span class=p>,</span> <span class=mf>2.8</span><span class=p>,</span> <span class=mf>4.7</span><span class=p>,</span> <span class=mf>1.9</span><span class=p>,</span> <span class=mf>4.7</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>prim</span><span class=p>(</span><span class=n>row_pointer</span><span class=p>,</span> <span class=n>column_index</span><span class=p>,</span> <span class=n>values</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>parent</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>parent</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/graphs/>Graphs</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>