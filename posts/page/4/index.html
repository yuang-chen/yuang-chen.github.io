<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Yac's Log</title><meta name=keywords content><meta name=description content="Posts - Yac's Log"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/posts/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>Graph Algorithms</h2></header><div class=entry-content><p>Considering myself a researcher in graph algorithms, I’ve come to the surprising realization that my grasp of these algorithms is not as solid as I thought. Hence, this blog series aims to document my exploration of various graph algorithms I’ve encountered thus far, regardless of their complexity.
The algorithms are selected from the parallel graph frameworks GAP and GBBS, focusing on their single-threaded versions to assess their complexity.
Breadth-First Search (BFS) Single-Source Shortest Paths (SSSP) Connected Components (CC) Betweenness Centrality (BC) Triangle Counting (TC) Minimum Spanning Tree (MST) Strongly Connected Components (SCC) SCAN Clustering (SCAN) Low Diameter Decomposition (LDD) Biconnected-Components (BC) Graph Coloring (COLOR) Maximal Matching (MM) Maximal Independent Set (MIS)</p></div><footer class=entry-footer><span title='2023-08-31 18:12:09 +0800 CST'>August 31, 2023</span>&nbsp;·&nbsp;111 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Graph Algorithms" href=https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/></a></article><article class=post-entry><header class=entry-header><h2>STL Containers</h2></header><div class=entry-content><p>In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I’ve been revisiting fundamental graph algorithms, I’ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.
They are:...</p></div><footer class=entry-footer><span title='2023-08-30 14:13:22 +0800 CST'>August 30, 2023</span>&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to STL Containers" href=https://yuang-chen.github.io/posts/2023-08-30-stl-containers/></a></article><article class=post-entry><header class=entry-header><h2>Scope Guard</h2></header><div class=entry-content><p>Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})....</p></div><footer class=entry-footer><span title='2023-08-29 10:27:54 +0800 CST'>August 29, 2023</span>&nbsp;·&nbsp;629 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scope Guard" href=https://yuang-chen.github.io/posts/2023-08-29-scope-guard/></a></article><article class=post-entry><header class=entry-header><h2>Static Local Member</h2></header><div class=entry-content><p>C++ templates are blueprints and don’t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include&lt;iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template&lt;typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component&lt;A> {}; class B : public Component&lt;B> {}; class C : public Component&lt;C> {}; int main() { std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; C::component_type_id() &lt;&lt; std::endl; // 2 } Key Points:...</p></div><footer class=entry-footer><span title='2023-08-27 11:45:15 +0800 CST'>August 27, 2023</span>&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Static Local Member" href=https://yuang-chen.github.io/posts/2023-08-27-static-local-member/></a></article><article class=post-entry><header class=entry-header><h2>Formatter Specialization</h2></header><div class=entry-content><p>We can customize the (printing) format of a given class by using the specialization of formatter.
#include &lt;format> #include &lt;iostream> struct Frac { int a, b; }; template &lt;> struct std::formatter&lt;Frac> : std::formatter&lt;string_view> { // parse() is inherited from the base class std::formatter&lt;string_view> // * an efficient solution: auto format(const Frac& frac, std::format_context& ctx) const { return std::format_to(ctx.out(), "{}/{}", frac.a, frac.b); } // the same functionality as above, but inefficient due to the temporary string // auto format(const Frac& frac, std::format_context& ctx) const { // std::string temp; // std::format_to(std::back_inserter(temp), "{}/{}", // frac....</p></div><footer class=entry-footer><span title='2023-08-25 19:56:16 +0800 CST'>August 25, 2023</span>&nbsp;·&nbsp;154 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Formatter Specialization" href=https://yuang-chen.github.io/posts/2023-08-25-formatter-specialization/></a></article><article class=post-entry><header class=entry-header><h2>User Defined Literals</h2></header><div class=entry-content><p>User Defined Literals (UDL) produces an object in an interesting way:
constexpr auto operator""_f(const char* fmt, size_t) { return[=]&lt;typename... T>(T&&... Args) { return std::vformat(fmt, std::make_format_args(std::forward&lt;T>(Args)...)); }; } auto s = "example {} see {}"_f("yep", 1.1); // s = "example yep 1.1" The UDL _f has the same effect of std::format("example {} see {}", "yep", 1.1). Pretty familiar (as libfmt), right?
Now, let’s break the definition of _f down:
int x = 10; double y = 3....</p></div><footer class=entry-footer><span title='2023-08-22 23:18:37 +0800 CST'>August 22, 2023</span>&nbsp;·&nbsp;330 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to User Defined Literals" href=https://yuang-chen.github.io/posts/2023-08-22-user-defined-literals/></a></article><article class=post-entry><header class=entry-header><h2>Operator Overload</h2></header><div class=entry-content><p>Reference: here.
The return of overloaded operator should be a reference, otherwise return-by-code will create a (temporary) rvalue that cannot be passed to the next operation f2 by non-const reference. i.e., rvalue cannot be non-const referenced.
#include &lt;vector> #include &lt;iostream> #include &lt;functional> template&lt;typename T, typename FN> requires std::invocable&lt;FN, T&> // diff std::invocable? std::vector&lt;T>& operator| (std::vector&lt;T>& vec, FN fn) noexcept { for(auto& e: vec) { fn(e); } return vec; } int main(){ std::vector v{1, 2, 3}; auto f1 = [](int& i) {i *= i; }; std::function f2 {[](const int& i) {std::cout &lt;&lt; i &lt;&lt; ' '; } }; v | f1 | f2; }```</p></div><footer class=entry-footer><span title='2023-08-17 10:36:19 +0800 CST'>August 17, 2023</span>&nbsp;·&nbsp;103 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Operator Overload" href=https://yuang-chen.github.io/posts/2023-08-17-operator-overload/></a></article><article class=post-entry><header class=entry-header><h2>Multidimensional Subscript Operator []</h2></header><div class=entry-content><p>Finally, C++23 allows overload for the subscript operator [] to be multi-dimensional.
Before that, we normally either use:
vector of vector to form a matrix, and access it as mat[i][j] a class containing a big 1-d vector, but behaves as 2-d by overloading the operator (), e.g., mat(i,j) Now, with C++23, we advance the second option (which offers efficient memory access) with better indexing approaching as follow:
template &lt;typename T, size_t R, size_t C> struct matrix { T& operator[](size_t const r, size_t const c) noexcept { return data_[r * C + c]; } T const& operator[](size_t const r, size_t const c) const noexcept { return data_[r * C + c]; } static constexpr size_t Rows = R; static constexpr size_t Columns = C; private: std::array&lt;T, R * C> data_; }; int main() { matrix&lt;int, 3, 2> m; for(size_t i = 0; i &lt; m....</p></div><footer class=entry-footer><span title='2023-05-13 22:11:07 +0800 CST'>May 13, 2023</span>&nbsp;·&nbsp;198 words&nbsp;·&nbsp;Yac</footer><a class=entry-link aria-label="post link to Multidimensional Subscript Operator []" href=https://yuang-chen.github.io/posts/2023-05-13-multidim-subscript-operator/></a></article><article class=post-entry><header class=entry-header><h2>Bitwise Op</h2></header><div class=entry-content><p>🦥 An old note.
Bitwise vs Arithmetic running on a vector of size 2^31, bitwise operations are significantly faster than arithmetic counterparts:
seg = 64; volume = (vec_size - 1)/ seg + 1; unsigned bs = log2(seg); unsigned bv= log2(volume); unsigned bbv = volume - 1; Arithmetic: out[i] = i % volume * seg + i / volume
Bitwise: out[i] = ((i & bbv) &lt;&lt; bs) + (i >> bv)...</p></div><footer class=entry-footer><span title='2023-05-07 23:33:24 +0800 CST'>May 7, 2023</span>&nbsp;·&nbsp;80 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bitwise Op" href=https://yuang-chen.github.io/posts/2023-05-07-bitwise-op/></a></article><article class=post-entry><header class=entry-header><h2>Omp Parallel Region</h2></header><div class=entry-content><p>The results look suspicious to me… But I wrote down this note many days ago 🦥. Maybe I need to evaluate it again.
Multiple Parallel Regions The cost of constructing parallel region is expensive in OpenMP. Let’s use two example for illustration:
Three loops operating on a vector of size 2^31, e.g.,
for(size_t i = 0; i &lt; vec.size(); i++) vec[i] += 1, vec[i] *= 0.9, vec[i] /= 7, Case 1: a large parallel region including the three loops by omp parallel { omp for }...</p></div><footer class=entry-footer><span title='2023-05-02 10:34:19 +0800 CST'>May 2, 2023</span>&nbsp;·&nbsp;238 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Omp Parallel Region" href=https://yuang-chen.github.io/posts/2023-05-02-omp-parallel-region/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://yuang-chen.github.io/posts/page/3/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://yuang-chen.github.io/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>