<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deque | Yac's Log</title><meta name=keywords content="STL"><meta name=description content="Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.
I&rsquo;ve hardly ever incorporated std::deque in my own coding projects, and it&rsquo;s a rarity in other people&rsquo;s work as well.
Code std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/posts/2023-09-04-deque/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Deque"><meta property="og:description" content="Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.
I&rsquo;ve hardly ever incorporated std::deque in my own coding projects, and it&rsquo;s a rarity in other people&rsquo;s work as well.
Code std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:"><meta property="og:type" content="article"><meta property="og:url" content="https://yuang-chen.github.io/posts/2023-09-04-deque/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-04T21:53:31+08:00"><meta property="article:modified_time" content="2023-09-04T21:53:31+08:00"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deque"><meta name=twitter:description content="Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.
I&rsquo;ve hardly ever incorporated std::deque in my own coding projects, and it&rsquo;s a rarity in other people&rsquo;s work as well.
Code std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yuang-chen.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Deque","item":"https://yuang-chen.github.io/posts/2023-09-04-deque/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deque","name":"Deque","description":"Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.\nI\u0026rsquo;ve hardly ever incorporated std::deque in my own coding projects, and it\u0026rsquo;s a rarity in other people\u0026rsquo;s work as well.\nCode std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:","keywords":["STL"],"articleBody":"Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.\nI’ve hardly ever incorporated std::deque in my own coding projects, and it’s a rarity in other people’s work as well.\nCode std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:\nblock_front block_back index_front inside the block_front index_back inside the block_back #include template \u003ctypename T\u003e class Deque { private: T** blocks; size_t block_size; size_t num_blocks; size_t blocks_used; size_t block_front; size_t block_back; size_t index_front; size_t index_back; size_t size_; public: Deque(); ~Deque(); void push_back(T elem); void push_front(T elem); void pop_back(); void pop_front(); T front(); T back(); bool empty(); T\u0026 at(size_t index); T\u0026 operator[](size_t index); size_t size() const; }; template \u003ctypename T\u003e Deque\u003cT\u003e::Deque() { num_blocks = 5; block_size = 8; blocks = new T*[num_blocks]; for(int i = 0; i \u003c num_blocks; i++) { blocks[i] = new T[block_size]; // elements are not initialized } // the starting block is the middle block block_front = num_blocks / 2; block_back = num_blocks / 2; // the starting index of element is at the middle of the block index_front = block_size / 2; index_back = block_size / 2 - 1; // ensures start with empty blocks_used = 0; size_ = 0; } template \u003ctypename T\u003e Deque\u003cT\u003e::~Deque() { for(int i = 0; i \u003c num_blocks; i++) { delete[] blocks[i]; } delete[] blocks; } /** * case breakdown: * 0. deque is empty * * just add the element * 1. current block is not full * * just add the element * 2. current block is full --\u003e further breakdown: * 2.1. there is space in the next block * * store the element in next block * * update the indexes * 2.2. there is no space in the next block * * create new blocks * * copy the elements to the new blocks * * delete the old blocks * * update the indexes */ template \u003ctypename T\u003e void Deque\u003cT\u003e::push_back(T elem) { //if the deque is empty if(size_ == 0) { blocks_used = 1; blocks[block_back][++index_back] = elem; size_++; return; } // if the block is not full if(index_back \u003c block_size - 1) { blocks[block_back][++index_back] = elem; size_++; return; } // ********************* // if current block is full //*********************** // if the next block is not full, move to it if(block_back \u003c num_blocks - 1) { index_back = 0; blocks[++block_back][index_back] = elem; size_++; blocks_used++; return; } // if the next block is full, allocate new blocks // 0 1 1 1 -\u003e 0 0 1 1 1 1 0 0 (8-3)/2 = 2 size_t old_block_front = block_front; num_blocks *= 2; index_back = 0; blocks_used++; size_++; block_front = (num_blocks - blocks_used) / 2; block_back = block_front + blocks_used - 1; T** new_blocks = new T*[num_blocks]; for(size_t i = 0; i \u003c block_front; i++) { new_blocks[i] = new T[block_size]; // allocate new blocks } for(size_t i = block_front; i \u003c block_back; i++) { new_blocks[i] = blocks[old_block_front++]; // reuse old blocks } for(size_t i = block_back; i \u003c num_blocks; i++) { new_blocks[i] = new T[block_size]; // allocate new blocks } new_blocks[block_back][0] = elem; // only delete the ptrptr** T** temp = blocks; blocks = new_blocks; delete[] temp; // std::cout \u003c\u003c \"Blocks: \" \u003c\u003c num_blocks \u003c\u003c std::endl; // std::cout \u003c\u003c \"Blocks used: \" \u003c\u003c blocks_used \u003c\u003c std::endl; // std::cout \u003c\u003c \"Block front: \" \u003c\u003c block_front \u003c\u003c std::endl; // std::cout \u003c\u003c \"Block back: \" \u003c\u003c block_back \u003c\u003c std::endl; // std::cout \u003c\u003c \"Index front: \" \u003c\u003c index_front \u003c\u003c std::endl; // std::cout \u003c\u003c \"Index back: \" \u003c\u003c index_back \u003c\u003c std::endl; // std::cout \u003c\u003c std::endl \u003c\u003c std::endl; } // reverse the push_back template \u003ctypename T\u003e void Deque\u003cT\u003e::push_front(T elem) { //if the deque is empty if(size_ == 0) { blocks_used = 1; blocks[block_front][--index_front] = elem; size_++; return; } // if the block is not full if(index_front \u003e 0) { blocks[block_front][--index_front] = elem; size_++; return; } // ********************* // if the block is full //*********************** // if the prior block is not full, move to it if(block_front \u003e 0) { index_front = block_size - 1; blocks[--block_front][index_front] = elem; size_++; blocks_used++; return; } // if the next block is full, allocate new blocks // 1 1 1 0 -\u003e 0 0 1 1 1 1 0 0 (8-3)/2 = 2 size_t old_block_front = block_front; num_blocks *= 2; index_front = block_size - 1; blocks_used++; size_++; block_front = (num_blocks - blocks_used) / 2; block_back = block_front + blocks_used - 1; T** new_blocks = new T*[num_blocks]; for(size_t i = 0; i \u003c block_front; i++) { new_blocks[i] = new T[block_size]; // allocate new blocks } for(size_t i = block_front; i \u003c block_back; i++) { new_blocks[i] = blocks[old_block_front++]; // reuse old blocks } for(size_t i = block_back; i \u003c num_blocks; i++) { new_blocks[i] = new T[block_size]; // allocate new blocks } new_blocks[block_front][index_front] = elem; // only delete the ptrptr** T** temp = blocks; blocks = new_blocks; delete[] temp; // std::cout \u003c\u003c \"Blocks: \" \u003c\u003c num_blocks \u003c\u003c std::endl; // std::cout \u003c\u003c \"Blocks used: \" \u003c\u003c blocks_used \u003c\u003c std::endl; // std::cout \u003c\u003c \"Block front: \" \u003c\u003c block_front \u003c\u003c std::endl; // std::cout \u003c\u003c \"Block back: \" \u003c\u003c block_back \u003c\u003c std::endl; // std::cout \u003c\u003c \"Index front: \" \u003c\u003c index_front \u003c\u003c std::endl; // std::cout \u003c\u003c \"Index back: \" \u003c\u003c index_back \u003c\u003c std::endl; // std::cout \u003c\u003c std::endl \u003c\u003c std::endl; } template \u003ctypename T\u003e void Deque\u003cT\u003e::pop_back() { if(size_ == 0) return; // if the back index is not 0 size_--; blocks[block_back][index_back] = std::numeric_limits\u003cT\u003e::max(); // register an error signal index_back--; // if the back index is 0, move to prior block if(index_back == std::numeric_limits\u003csize_t\u003e::max()) // if(int(index_back) == -1) { index_back = block_size - 1; block_back--; } } template \u003ctypename T\u003e void Deque\u003cT\u003e::pop_front() { if(size_ == 0) { return; } // if the back index is not 0 size_--; blocks[block_front][index_front] = std::numeric_limits\u003cT\u003e::max(); // register an error signal index_front++; // if the back index is 0 if(index_front == block_size) { block_front++; index_front = 0; } } template \u003ctypename T\u003e T Deque\u003cT\u003e::back() { return blocks[block_back][index_back]; } template \u003ctypename T\u003e T Deque\u003cT\u003e::front() { return blocks[block_front][index_front]; } template \u003ctypename T\u003e bool Deque\u003cT\u003e::empty() { return size_ == 0; } template \u003ctypename T\u003e T\u0026 Deque\u003cT\u003e::operator[](size_t index) // do not perform boundary checking { const size_t remain = block_size - index_front; if(index \u003c remain) { return blocks[block_front][index_front + index]; } size_t curr_block = block_front + (index + remain) / block_size; size_t curr_index = (index + remain) % block_size; return blocks[curr_block][curr_index]; } template \u003ctypename T\u003e T\u0026 Deque\u003cT\u003e::at(size_t index) // perform boundary checking { if(index \u003e= size_) { throw std::out_of_range(\"Deque::at() index out of range\"); } const size_t remain = block_size - index_front; if(index \u003c remain) { return blocks[block_front][index_front + index]; } const size_t curr_block = block_front + (index + remain) / block_size; const size_t curr_index = (index + remain) % block_size; return blocks[curr_block][curr_index]; } template \u003ctypename T\u003e size_t Deque\u003cT\u003e::size() const { return size_; } int main() { Deque\u003cint\u003e deq; std::cout \u003c\u003c \"-----push_back test-----\" \u003c\u003c std::endl; for(int i = 0; i \u003c 21; i++) { deq.push_back(i); std::cout \u003c\u003c deq.back() \u003c\u003c ' '; } std::cout \u003c\u003c \"\\n-----pop_back test-----\" \u003c\u003c std::endl; for(int i = 0; i \u003c 21; i++) { std::cout \u003c\u003c deq.back() \u003c\u003c ' '; deq.pop_back(); } std::cout \u003c\u003c \"\\n-----push_front test-----\" \u003c\u003c std::endl; for(int i = 0; i \u003c 21; i++) { deq.push_front(i); std::cout \u003c\u003c deq.front() \u003c\u003c ' '; } std::cout \u003c\u003c \"\\n-----pop_front test-----\" \u003c\u003c std::endl; for(int i = 0; i \u003c 21; i++) { std::cout \u003c\u003c deq.front() \u003c\u003c ' '; deq.pop_front(); } std::cout \u003c\u003c \"\\n-----operator[] test-----\" \u003c\u003c std::endl; for(int i = 0; i \u003c 11; i++) deq.push_back(i); for(int i = 0; i \u003c 12; i++) { std::cout \u003c\u003c deq[i] \u003c\u003c ' '; } std::cout \u003c\u003c \"\\n-----at() test-----\" \u003c\u003c std::endl; std::cout \u003c\u003c deq.size() \u003c\u003c std::endl; for(int i = 0; i \u003c 12; i++) { std::cout \u003c\u003c deq.at(i) \u003c\u003c ' '; } } Reference https://stackoverflow.com/questions/6292332/what-really-is-a-deque-in-stl https://github.com/rdmc10/Deque/blob/main/deque.cpp https://en.cppreference.com/w/cpp/container/deque\n","wordCount":"1309","inLanguage":"en","datePublished":"2023-09-04T21:53:31+08:00","dateModified":"2023-09-04T21:53:31+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yuang-chen.github.io/posts/2023-09-04-deque/"},"publisher":{"@type":"Organization","name":"Yac's Log","logo":{"@type":"ImageObject","url":"https://yuang-chen.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Deque</h1><div class=post-meta><span title='2023-09-04 21:53:31 +0800 HKT'>September 4, 2023</span>&nbsp;·&nbsp;1309 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h2 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h2><p><code>std::deque</code> extends the interfaces of <code>std::vector</code> with <code>push_front</code>, <code>pop_front</code>, etc., such that elements can be inserted or removed at the end or beginning at constant time.</p><p>I&rsquo;ve hardly ever incorporated std::deque in my own coding projects, and it&rsquo;s a rarity in other people&rsquo;s work as well.</p><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p><code>std::deque</code> is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:</p><ol><li><code>block_front</code></li><li><code>block_back</code></li><li><code>index_front</code> inside the <code>block_front</code></li><li><code>index_back</code> inside the <code>block_back</code></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Deque</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>**</span>    <span class=n>blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>block_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>num_blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>blocks_used</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>block_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>block_back</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>index_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>index_back</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>Deque</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>Deque</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span>   <span class=nf>push_back</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span>   <span class=nf>push_front</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span>   <span class=nf>pop_back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span>   <span class=nf>pop_front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span>      <span class=nf>front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span>      <span class=nf>back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span>   <span class=nf>empty</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>&amp;</span>     <span class=n>at</span><span class=p>(</span><span class=n>size_t</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>&amp;</span>     <span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>num_blocks</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_size</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks</span>     <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=o>*</span><span class=p>[</span><span class=n>num_blocks</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_blocks</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>block_size</span><span class=p>];</span>    <span class=c1>// elements are not initialized
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the starting block is the middle block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>block_front</span> <span class=o>=</span> <span class=n>num_blocks</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_back</span>  <span class=o>=</span> <span class=n>num_blocks</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// the starting index of element is at the middle of the block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>index_front</span> <span class=o>=</span> <span class=n>block_size</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>index_back</span>  <span class=o>=</span> <span class=n>block_size</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>    <span class=c1>// ensures start with empty
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>blocks_used</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_</span>       <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::~</span><span class=n>Deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_blocks</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>blocks</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span><span class=p>[]</span> <span class=n>blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * case breakdown:
</span></span></span><span class=line><span class=cl><span class=cm> * 0. deque is empty
</span></span></span><span class=line><span class=cl><span class=cm> *   * just add the element
</span></span></span><span class=line><span class=cl><span class=cm> * 1. current block is not full
</span></span></span><span class=line><span class=cl><span class=cm> *   * just add the element
</span></span></span><span class=line><span class=cl><span class=cm> * 2. current block is full --&gt; further breakdown:
</span></span></span><span class=line><span class=cl><span class=cm> * 2.1. there is space in the next block
</span></span></span><span class=line><span class=cl><span class=cm> *   * store the element in next block
</span></span></span><span class=line><span class=cl><span class=cm> *   * update the indexes
</span></span></span><span class=line><span class=cl><span class=cm> * 2.2. there is no space in the next block
</span></span></span><span class=line><span class=cl><span class=cm> *   * create new blocks
</span></span></span><span class=line><span class=cl><span class=cm> *   * copy the elements to the new blocks
</span></span></span><span class=line><span class=cl><span class=cm> *   * delete the old blocks
</span></span></span><span class=line><span class=cl><span class=cm> *   * update the indexes
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>push_back</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//if the deque is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>size_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks_used</span>                      <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=n>block_back</span><span class=p>][</span><span class=o>++</span><span class=n>index_back</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the block is not full
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>index_back</span> <span class=o>&lt;</span> <span class=n>block_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=n>block_back</span><span class=p>][</span><span class=o>++</span><span class=n>index_back</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// *********************
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// if current block is full
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//***********************
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// if the next block is not full, move to it
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>block_back</span> <span class=o>&lt;</span> <span class=n>num_blocks</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>index_back</span>                       <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=o>++</span><span class=n>block_back</span><span class=p>][</span><span class=n>index_back</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks_used</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// if the next block is full, allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//  0 1 1 1 -&gt; 0 0 1 1 1 1 0 0  (8-3)/2 = 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_t</span> <span class=n>old_block_front</span> <span class=o>=</span> <span class=n>block_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>num_blocks</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>index_back</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks_used</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_front</span>    <span class=o>=</span> <span class=p>(</span><span class=n>num_blocks</span> <span class=o>-</span> <span class=n>blocks_used</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_back</span>     <span class=o>=</span> <span class=n>block_front</span> <span class=o>+</span> <span class=n>blocks_used</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>**</span> <span class=n>new_blocks</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=o>*</span><span class=p>[</span><span class=n>num_blocks</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>block_front</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>block_size</span><span class=p>];</span>    <span class=c1>// allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=n>block_front</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>block_back</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>blocks</span><span class=p>[</span><span class=n>old_block_front</span><span class=o>++</span><span class=p>];</span>    <span class=c1>// reuse old blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=n>block_back</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_blocks</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>block_size</span><span class=p>];</span>    <span class=c1>// allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>new_blocks</span><span class=p>[</span><span class=n>block_back</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// only delete the ptrptr**
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>T</span><span class=o>**</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks</span>   <span class=o>=</span> <span class=n>new_blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span><span class=p>[]</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// std::cout &lt;&lt; &#34;Blocks:      &#34; &lt;&lt; num_blocks &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Blocks used: &#34; &lt;&lt; blocks_used &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Block front: &#34; &lt;&lt; block_front &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Block back:  &#34; &lt;&lt; block_back &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Index front: &#34; &lt;&lt; index_front &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Index back:  &#34; &lt;&lt; index_back &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// reverse the push_back
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>push_front</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//if the deque is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>size_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks_used</span>                        <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=o>--</span><span class=n>index_front</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the block is not full
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>index_front</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=o>--</span><span class=n>index_front</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// *********************
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// if the block is full
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//***********************
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// if the prior block is not full, move to it
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>block_front</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>index_front</span>                        <span class=o>=</span> <span class=n>block_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks</span><span class=p>[</span><span class=o>--</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>blocks_used</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// if the next block is full, allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   1 1 1 0 -&gt; 0 0 1 1 1 1 0 0  (8-3)/2 = 2
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_t</span> <span class=n>old_block_front</span> <span class=o>=</span> <span class=n>block_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>num_blocks</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>index_front</span> <span class=o>=</span> <span class=n>block_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks_used</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_front</span>    <span class=o>=</span> <span class=p>(</span><span class=n>num_blocks</span> <span class=o>-</span> <span class=n>blocks_used</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>block_back</span>     <span class=o>=</span> <span class=n>block_front</span> <span class=o>+</span> <span class=n>blocks_used</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span><span class=o>**</span> <span class=n>new_blocks</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=o>*</span><span class=p>[</span><span class=n>num_blocks</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>block_front</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>block_size</span><span class=p>];</span>    <span class=c1>// allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=n>block_front</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>block_back</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>blocks</span><span class=p>[</span><span class=n>old_block_front</span><span class=o>++</span><span class=p>];</span>    <span class=c1>// reuse old blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=n>block_back</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_blocks</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new_blocks</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>block_size</span><span class=p>];</span>    <span class=c1>// allocate new blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>new_blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span><span class=p>]</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// only delete the ptrptr**
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>T</span><span class=o>**</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks</span>   <span class=o>=</span> <span class=n>new_blocks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span><span class=p>[]</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// std::cout &lt;&lt; &#34;Blocks:      &#34; &lt;&lt; num_blocks &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Blocks used: &#34; &lt;&lt; blocks_used &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Block front: &#34; &lt;&lt; block_front &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Block back:  &#34; &lt;&lt; block_back &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Index front: &#34; &lt;&lt; index_front &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; &#34;Index back:  &#34; &lt;&lt; index_back &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>pop_back</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>size_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the back index is not 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks</span><span class=p>[</span><span class=n>block_back</span><span class=p>][</span><span class=n>index_back</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>();</span>    <span class=c1>// register an error signal
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>index_back</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the back index is 0, move to prior block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>index_back</span> <span class=o>==</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>())</span>    <span class=c1>// if(int(index_back) == -1)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>index_back</span> <span class=o>=</span> <span class=n>block_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>block_back</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>pop_front</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>size_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the back index is not 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>();</span>    <span class=c1>// register an error signal
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>index_front</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if the back index is 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>index_front</span> <span class=o>==</span> <span class=n>block_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>block_front</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>index_front</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>back</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>block_back</span><span class=p>][</span><span class=n>index_back</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>front</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>empty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>size_</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span><span class=o>&amp;</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=p>[](</span><span class=n>size_t</span> <span class=n>index</span><span class=p>)</span>    <span class=c1>// do not perform boundary checking
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>remain</span> <span class=o>=</span> <span class=n>block_size</span> <span class=o>-</span> <span class=n>index_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>remain</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span> <span class=o>+</span> <span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>curr_block</span> <span class=o>=</span> <span class=n>block_front</span> <span class=o>+</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>remain</span><span class=p>)</span> <span class=o>/</span> <span class=n>block_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>curr_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>remain</span><span class=p>)</span> <span class=o>%</span> <span class=n>block_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>curr_block</span><span class=p>][</span><span class=n>curr_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span><span class=o>&amp;</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>at</span><span class=p>(</span><span class=n>size_t</span> <span class=n>index</span><span class=p>)</span>    <span class=c1>// perform boundary checking
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>out_of_range</span><span class=p>(</span><span class=s>&#34;Deque::at() index out of range&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>remain</span> <span class=o>=</span> <span class=n>block_size</span> <span class=o>-</span> <span class=n>index_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>remain</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>block_front</span><span class=p>][</span><span class=n>index_front</span> <span class=o>+</span> <span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>curr_block</span> <span class=o>=</span> <span class=n>block_front</span> <span class=o>+</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>remain</span><span class=p>)</span> <span class=o>/</span> <span class=n>block_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>curr_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>remain</span><span class=p>)</span> <span class=o>%</span> <span class=n>block_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>blocks</span><span class=p>[</span><span class=n>curr_block</span><span class=p>][</span><span class=n>curr_index</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>size</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>deq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;-----push_back test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>21</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>deq</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----pop_back test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>21</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>deq</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----push_front test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>21</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>deq</span><span class=p>.</span><span class=n>push_front</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>front</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----pop_front test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>21</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>front</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>deq</span><span class=p>.</span><span class=n>pop_front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----operator[] test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>11</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>deq</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>12</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>-----at() test-----&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>12</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>deq</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=https://stackoverflow.com/questions/6292332/what-really-is-a-deque-in-stl>https://stackoverflow.com/questions/6292332/what-really-is-a-deque-in-stl</a>
<a href=https://github.com/rdmc10/Deque/blob/main/deque.cpp>https://github.com/rdmc10/Deque/blob/main/deque.cpp</a>
<a href=https://en.cppreference.com/w/cpp/container/deque>https://en.cppreference.com/w/cpp/container/deque</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuang-chen.github.io/tags/stl/>STL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>