<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Yac's Log</title><meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="Blog"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/index.xml><link rel=alternate type=application/json href=https://yuang-chen.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Yac's Log"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Yac's Log"><meta name=twitter:description content="Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Yac's Log","url":"https://yuang-chen.github.io/","description":"Blog","thumbnailUrl":"https://yuang-chen.github.io/favicon/favicon.ico","sameAs":["https://www.linkedin.com/in/yuang-chen/","https://github.com/yuang-chen"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>List</h2></header><div class=entry-content><p>Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.
A valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures....</p></div><footer class=entry-footer><span title='2023-09-11 16:33:34 +0800 HKT'>September 11, 2023</span>&nbsp;·&nbsp;707 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to List" href=https://yuang-chen.github.io/posts/2023-09-11-list/></a></article><article class=post-entry><header class=entry-header><h2>SSSP</h2></header><div class=entry-content><p>Two variants of Single-Source Shortest Path (SSSP) have been implemented as follows. Bellman-Ford is the one that is widely implemented in parallel graph frameworks. This is because the use of a heap in Dijkstra’s algorithm can limit the parallelism of the code.
Criteria Dijkstra’s Algorithm Bellman-Ford Algorithm Type Greedy Dynamic Programming Usage Positive weights Negative weights OK Time Complexity O((V + E) * log(V)) O(V * E) Negative Cycles No Yes (Detectable) Data Structures Priority Queue None (Arrays) Initialization Start node: 0, rest ∞ Start node: 0, rest ∞ Relaxation Decrease Key Relaxation BellmanFord BellmanFord: Perform numVertices - 1 iterations of graph traversal to find the shortest path an additional iteration checks if negative cycles exist $O(|V| * |E|)$ time complexity Code #include &lt;iostream> #include &lt;queue> #include &lt;vector> std::vector&lt;int> bellmanFord(const int root, const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx, const std::vector&lt;float>& weight) { const auto numVertices = rowPtr....</p></div><footer class=entry-footer><span title='2023-09-09 13:36:19 +0800 HKT'>September 9, 2023</span>&nbsp;·&nbsp;845 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SSSP" href=https://yuang-chen.github.io/posts/2023-09-09-sssp/></a></article><article class=post-entry><header class=entry-header><h2>Deque</h2></header><div class=entry-content><p>Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.
I’ve hardly ever incorporated std::deque in my own coding projects, and it’s a rarity in other people’s work as well.
Code std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:...</p></div><footer class=entry-footer><span title='2023-09-04 21:53:31 +0800 HKT'>September 4, 2023</span>&nbsp;·&nbsp;1309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deque" href=https://yuang-chen.github.io/posts/2023-09-04-deque/></a></article><article class=post-entry><header class=entry-header><h2>Vector & Array</h2></header><div class=entry-content><p>Array is allocated in stack memory Vector is allocated in heap memory. Its capacity is “pre-allocated”. #include &lt;iostream> template&lt;typename T> class Vector { private: T* data_; size_t size_; size_t capacity_; public: Vector(): data_(nullptr), size_(0), capacity_(0) {} Vector(size_t n_): size_(n_), capacity_(n_) { data_ = new T[n_]; } ~Vector() { delete [] data_; }; T& operator[] (size_t index) { return data_[index]; } const T& operator[] (size_t index) const { return data_[index]; } size_t size() const { return size_; } void push_back(const T& value) { if(size_ == capacity_) { capacity_ = size_ == 0?...</p></div><footer class=entry-footer><span title='2023-09-02 10:59:59 +0800 HKT'>September 2, 2023</span>&nbsp;·&nbsp;202 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Vector & Array" href=https://yuang-chen.github.io/posts/2023-09-02-vector-array/></a></article><article class=post-entry><header class=entry-header><h2>BFS & DFS</h2></header><div class=entry-content><p>Iterative BFS Despite its apparent simplicity, this approach relies heavily on the utilization of various STL containers. std::unordered_map records the parent of each node std::unordered_set checks if a node has been visited std::queue allows the nodes be accessed in the width-first flow; using std::stack for depth-first flow std::stack reverses the parents, so the path can be printed in root-to-target order. #include &lt;iostream> #include &lt;vector> #include &lt;unordered_map> #include &lt;unordered_set> #include &lt;queue> #include &lt;stack> std::stack&lt;int> BFS(const int root, const int target, const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { std::unordered_map&lt;int, int> parent; std::unordered_set&lt;int> visited; std::queue&lt;int> nodeQue; // std::stack&lt;int> nodeStk for DFS std::stack&lt;int> path; bool hasFound = false; nodeQue....</p></div><footer class=entry-footer><span title='2023-09-01 11:17:51 +0800 HKT'>September 1, 2023</span>&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BFS & DFS" href=https://yuang-chen.github.io/posts/2023-09-01-bfs/></a></article><article class=post-entry><header class=entry-header><h2>Graph Algorithms</h2></header><div class=entry-content><p>Considering myself a researcher in graph algorithms, I’ve come to the surprising realization that my grasp of these algorithms is not as solid as I thought. Hence, this blog series aims to document my exploration of various graph algorithms I’ve encountered thus far, regardless of their complexity.
The algorithms are selected from the parallel graph frameworks GAP and GBBS, focusing on their single-threaded versions to assess their complexity.
Breadth-First Search (BFS) Single-Source Shortest Paths (SSSP) Connected Components (CC) Betweenness Centrality (BC) Triangle Counting (TC) Minimum Spanning Tree (MST) Strongly Connected Components (SCC) SCAN Clustering (SCAN) Low Diameter Decomposition (LDD) Biconnected-Components (BC) Graph Coloring (COLOR) Maximal Matching (MM) Maximal Independent Set (MIS)</p></div><footer class=entry-footer><span title='2023-08-31 18:12:09 +0800 HKT'>August 31, 2023</span>&nbsp;·&nbsp;111 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Graph Algorithms" href=https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/></a></article><article class=post-entry><header class=entry-header><h2>STL Containers</h2></header><div class=entry-content><p>In my HPC-oriented programming, my go-to choices are typically limited to arrays and vectors because of their memory efficiency. Linked lists and hash maps, being non-contiguous in memory space, rarely find their way into my toolkit. These containers draw upon many classic algorithmic designs. Lately, as I’ve been revisiting fundamental graph algorithms, I’ve also decided to take on the tasks of re-implementing these containers in a simplified illustration.
They are:...</p></div><footer class=entry-footer><span title='2023-08-30 14:13:22 +0800 HKT'>August 30, 2023</span>&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to STL Containers" href=https://yuang-chen.github.io/posts/2023-08-30-stl-containers/></a></article><article class=post-entry><header class=entry-header><h2>Scope Guard</h2></header><div class=entry-content><p>Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})....</p></div><footer class=entry-footer><span title='2023-08-29 10:27:54 +0800 HKT'>August 29, 2023</span>&nbsp;·&nbsp;629 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scope Guard" href=https://yuang-chen.github.io/posts/2023-08-29-scope-guard/></a></article><article class=post-entry><header class=entry-header><h2>Static Local Member</h2></header><div class=entry-content><p>C++ templates are blueprints and don’t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include&lt;iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template&lt;typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component&lt;A> {}; class B : public Component&lt;B> {}; class C : public Component&lt;C> {}; int main() { std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; C::component_type_id() &lt;&lt; std::endl; // 2 } Key Points:...</p></div><footer class=entry-footer><span title='2023-08-27 11:45:15 +0800 HKT'>August 27, 2023</span>&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Static Local Member" href=https://yuang-chen.github.io/posts/2023-08-27-static-local-member/></a></article><article class=post-entry><header class=entry-header><h2>Formatter Specialization</h2></header><div class=entry-content><p>We can customize the (printing) format of a given class by using the specialization of formatter.
#include &lt;format> #include &lt;iostream> struct Frac { int a, b; }; template &lt;> struct std::formatter&lt;Frac> : std::formatter&lt;string_view> { // parse() is inherited from the base class std::formatter&lt;string_view> // * an efficient solution: auto format(const Frac& frac, std::format_context& ctx) const { return std::format_to(ctx.out(), "{}/{}", frac.a, frac.b); } // the same functionality as above, but inefficient due to the temporary string // auto format(const Frac& frac, std::format_context& ctx) const { // std::string temp; // std::format_to(std::back_inserter(temp), "{}/{}", // frac....</p></div><footer class=entry-footer><span title='2023-08-25 19:56:16 +0800 HKT'>August 25, 2023</span>&nbsp;·&nbsp;154 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Formatter Specialization" href=https://yuang-chen.github.io/posts/2023-08-25-formatter-specialization/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://yuang-chen.github.io/page/2/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://yuang-chen.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>