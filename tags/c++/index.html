<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | Yac's Log</title><meta name=keywords content><meta name=description content="Blog"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/tags/c++/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/tags/c++/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="C++"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/tags/c++/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content="Blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>C++
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Initializer List</h2></header><div class=entry-content><p>In a prior post, I talked about list initialization, which is differs from initializer_list discussed here. Though personally, I don’t find initializer_list really useful as I never used it in my projects.
list initialization is a general syntax using {} for initializing a variety of variables and objects. initializer_list is a template class representing a lightweight, read-only array of elements, typically used in constructors or functions. initializer_list promotes safety, flexibility and modern tone compared to the raw array....</p></div><footer class=entry-footer><span title='2024-12-28 23:03:50 +0800 CST'>December 28, 2024</span>&nbsp;·&nbsp;541 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Initializer List" href=https://yuang-chen.github.io/posts/2024-12-28-initializer-list/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>`constexpr` from the perspective of assembly code</h2></header><div class=entry-content><p>constexpr is a keyword in C++ that allows the compiler to evaluate expressions at compile time. This is a powerful feature that can significantly optimize performance by reducing runtime overhead.
However, I mainly use it for type-related operations. I seldom apply it to data-related tasks, since defining data with constexpr requires constant values, which is rarely feasible in my projects.
Code with constexpr #include &lt;stddef.h> #include &lt;string_view> #include &lt;algorithm> #include &lt;cstdio> template&lt;size_t N> class FixedString { size_t mSize{}; char mData[N]{}; public: FixedString() = default; // Constructor that computes string length at compile time constexpr FixedString(const char* str) : mSize{std::char_traits&lt;char>::length(str)} { std::copy_n(str, size(), mData); } constexpr size_t size() const { return mSize; } constexpr std::string_view string_view() const { return {mData, mSize}; } }; template&lt;size_t N> constexpr auto make_fixed_string(const char (&amp;str)[N]) { return FixedString&lt;N>{str}; } constexpr const static FixedString&lt;50> x{"Hello, embedded World!...</p></div><footer class=entry-footer><span title='2024-12-24 10:58:30 +0800 CST'>December 24, 2024</span>&nbsp;·&nbsp;353 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to `constexpr` from the perspective of assembly code" href=https://yuang-chen.github.io/posts/2024-12-24-constexpr-assembly/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Stateless Type</h2></header><div class=entry-content><p>In C++, the term “stateless” typically refers to a type (class or struct) that:
Has no non-static data members, meaning it does not store any instance-specific information. Does not maintain any internal state or data that varies between objects of that type. Stateless types are often empty classes used for utility purposes, such as:
Custom deleters for smart pointers. #include &lt;memory> #include &lt;iostream> struct EmptyDeleter { void operator()(int* ptr) const { delete ptr; std::cout &lt;&lt; "Deleted\n"; } }; int main() { std::unique_ptr&lt;int, EmptyDeleter> ptr(new int(42)); std::cout &lt;&lt; "Size of unique_ptr: " &lt;&lt; sizeof(ptr) &lt;&lt; " bytes\n"; // 8 bytes return 0; } Tags for template metaprogramming....</p></div><footer class=entry-footer><span title='2024-12-20 09:18:21 +0800 CST'>December 20, 2024</span>&nbsp;·&nbsp;205 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stateless Type" href=https://yuang-chen.github.io/posts/2024-12-20-stateless-type/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Empty Data Members</h2></header><div class=entry-content><p>[[no_unique_address]] since C++20 [[no_unique_address]] applies to user-defined types (e.g., empty or stateless classes or structs). It does not apply to fundamental types (int, float, etc.), as they always require memory for storage. The attribute optimizes memory layout by allowing empty or stateless user-defined types to overlap memory locations, improving efficiency without violating the C++ object model. Motivation Prior to C++20, Empty Base Optimization (EBO) allowed an empty base class to take zero space when it was inherited by another class....</p></div><footer class=entry-footer><span title='2024-12-19 09:27:28 +0800 CST'>December 19, 2024</span>&nbsp;·&nbsp;253 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Empty Data Members" href=https://yuang-chen.github.io/posts/2024-12-19-empty-data-members/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Struct Alignment and Padding</h2></header><div class=entry-content><p>In a struct, the padded bytes depend on the alignment requirement of the next member following the current member, because the compiler must ensure proper and efficient access to memory.
Alignment Requirement: Each data type has a required alignment, which is typically a power of two. For example:
char: 1-byte alignment int: 4-byte alignment long (on a 64-bit system): 8-byte alignment double: 8-byte alignment Padding: When laying out struct members, if the next member needs stricter (i....</p></div><footer class=entry-footer><span title='2024-12-18 09:25:40 +0800 CST'>December 18, 2024</span>&nbsp;·&nbsp;209 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Struct Alignment and Padding" href=https://yuang-chen.github.io/posts/2024-12-18-alignment-and-padding/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Empty Struct</h2></header><div class=entry-content><p>Definition of an Empty Class An empty class is a class that:
Contains no non-static data members. May include: Member functions (including operator() or constructors), but these do not contribute to the class size. Static data members, because these are shared across all instances and are not part of the object layout. Does not use virtual functions or polymorphism, which would require the inclusion of a vtable pointer. Inherits from another empty class, as the derived class can still remain empty due to Empty Base Optimization (EBO)....</p></div><footer class=entry-footer><span title='2024-12-14 10:08:30 +0800 CST'>December 14, 2024</span>&nbsp;·&nbsp;505 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Empty Struct" href=https://yuang-chen.github.io/posts/2024-12-14-empty-struct/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[CppCon] Fast and Small C++</h2></header><div class=entry-content><p>Recently, I watched this talk by Andreas Fertig at CppCon'24. He discussed some very interesting topics, including new C++ features and union-based optimizations for efficient C++ programming.
To fully understand this talk byte by byte, I tried to re-implement the examples and experiment on my own, figuring out details with the help of ChatGPT. But I quickly found myself going down a rabbit hole of unfamiliar concepts that I’m not quite up to grasp yet....</p></div><footer class=entry-footer><span title='2024-12-13 10:49:22 +0800 CST'>December 13, 2024</span>&nbsp;·&nbsp;163 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to [CppCon] Fast and Small C++" href=https://yuang-chen.github.io/posts/2024-12-13-cppcon-fast-and-small/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Constrained Non Type Template Parameter</h2></header><div class=entry-content><p>NTTP (C++98): Allows templates to accept non-type parameters like integers or pointers, enhancing flexibility and efficiency. CNTTP (C++20): Extends NTTP by using concepts to constrain non-type parameters, improving type safety and expressiveness. Code Example #include &lt;concepts> #include &lt;cstddef> // Function using NTTP template&lt;size_t i> // size_t is unsigned, so negative values will cause an error auto get_value_nttp() { return i; } // Function using CNTTP template&lt;std::integral auto I> // constrained to integral types auto get_value_cnttp() { return I; } int main() { // NTTP example auto x = get_value_nttp&lt;10>(); // correct, 10 is a valid size_t // auto y = get_value_nttp&lt;-10>(); // error, -10 is not a valid size_t (uncomment to see the error) // CNTTP example auto w = get_value_cnttp&lt;10>(); // correct, 10 is an integral type auto z = get_value_cnttp&lt;-10>(); // correct, -10 is an integral type return 0; }</p></div><footer class=entry-footer><span title='2024-06-17 09:30:14 +0800 CST'>June 17, 2024</span>&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Constrained Non Type Template Parameter" href=https://yuang-chen.github.io/posts/2024-06-17-constrained-non-type-template-parameter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Class Template Argument Deduction</h2></header><div class=entry-content><p>Class Template Argument Deduction (CTAD) is a feature introduced in C++17 that allows the compiler to deduce the template arguments for class templates from the constructor arguments. This makes code more concise and avoids the need for explicit template arguments.
Example without CTAD: #include &lt;vector> #include &lt;iostream> int main() { std::vector&lt;int> vec = {1, 2, 3, 4, 5}; // Explicit template argument for (const auto& elem : vec) { std::cout &lt;&lt; elem &lt;&lt; " "; } return 0; } Example with CTAD: #include &lt;vector> #include &lt;iostream> int main() { std::vector vec1 = {1, 2, 3, 4, 5}; // CTAD deduces std::vector&lt;int> std::vector vec2 = {1....</p></div><footer class=entry-footer><span title='2024-05-07 09:05:16 +0800 CST'>May 7, 2024</span>&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class Template Argument Deduction" href=https://yuang-chen.github.io/posts/2024-05-07-class-template-argument-deduction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Non-Virtual Polymorphism</h2></header><div class=entry-content><p>Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.
Notice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant....</p></div><footer class=entry-footer><span title='2024-01-24 09:33:57 +0800 CST'>January 24, 2024</span>&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Non-Virtual Polymorphism" href=https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://yuang-chen.github.io/tags/c++/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>