<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | Yac's Log</title><meta name=keywords content><meta name=description content="Blog"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/tags/c++/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/tags/c++/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="C++"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/tags/c++/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content="Blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>C++
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Empty Struct</h2></header><div class=entry-content><p>Size of Empty Struct In C++, an empty struct has a size of 1 byte. This is due to the C++ standard requirement that no two distinct objects can have the same memory address, so even empty structures must have a non-zero size.
The minimum addressable unit in most computer architectures is 1 byte So while it might seem logical to make it 0 bytes since it contains no data, that would violate the requirement that objects must have unique addresses....</p></div><footer class=entry-footer><span title='2024-12-14 10:08:30 +0800 CST'>December 14, 2024</span>&nbsp;·&nbsp;283 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Empty Struct" href=https://yuang-chen.github.io/posts/2024-12-14-empty-struct/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Constrained Non Type Template Parameter</h2></header><div class=entry-content><p>NTTP (C++98): Allows templates to accept non-type parameters like integers or pointers, enhancing flexibility and efficiency. CNTTP (C++20): Extends NTTP by using concepts to constrain non-type parameters, improving type safety and expressiveness. Code Example #include &lt;concepts> #include &lt;cstddef> // Function using NTTP template&lt;size_t i> // size_t is unsigned, so negative values will cause an error auto get_value_nttp() { return i; } // Function using CNTTP template&lt;std::integral auto I> // constrained to integral types auto get_value_cnttp() { return I; } int main() { // NTTP example auto x = get_value_nttp&lt;10>(); // correct, 10 is a valid size_t // auto y = get_value_nttp&lt;-10>(); // error, -10 is not a valid size_t (uncomment to see the error) // CNTTP example auto w = get_value_cnttp&lt;10>(); // correct, 10 is an integral type auto z = get_value_cnttp&lt;-10>(); // correct, -10 is an integral type return 0; }</p></div><footer class=entry-footer><span title='2024-06-17 09:30:14 +0800 CST'>June 17, 2024</span>&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Constrained Non Type Template Parameter" href=https://yuang-chen.github.io/posts/2024-06-17-constrained-non-type-template-parameter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Class Template Argument Deduction</h2></header><div class=entry-content><p>Class Template Argument Deduction (CTAD) is a feature introduced in C++17 that allows the compiler to deduce the template arguments for class templates from the constructor arguments. This makes code more concise and avoids the need for explicit template arguments.
Example without CTAD: #include &lt;vector> #include &lt;iostream> int main() { std::vector&lt;int> vec = {1, 2, 3, 4, 5}; // Explicit template argument for (const auto& elem : vec) { std::cout &lt;&lt; elem &lt;&lt; " "; } return 0; } Example with CTAD: #include &lt;vector> #include &lt;iostream> int main() { std::vector vec1 = {1, 2, 3, 4, 5}; // CTAD deduces std::vector&lt;int> std::vector vec2 = {1....</p></div><footer class=entry-footer><span title='2024-05-07 09:05:16 +0800 CST'>May 7, 2024</span>&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class Template Argument Deduction" href=https://yuang-chen.github.io/posts/2024-05-07-class-template-argument-deduction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Non-Virtual Polymorphism</h2></header><div class=entry-content><p>Modern Features in C++17 Non-virtual runtime polymorphism can be achieved with modern C++ (e.g., C++17) features std::any and std::variant as described in the table below.
Notice std::tuple is not used for polymorphism; it offers a structured way to manage multiple values of different types simultaneously, such as in function return types, or parameter packs. It is put here because of its usage is a bit similar to std::any and std::variant....</p></div><footer class=entry-footer><span title='2024-01-24 09:33:57 +0800 CST'>January 24, 2024</span>&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Non-Virtual Polymorphism" href=https://yuang-chen.github.io/posts/2024-01-24-non-virtual-polymorphism/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Observable Behaviors</h2></header><div class=entry-content><p>What is Observable Behavior & Related Issues The term observable behavior, according to the standard, means the following:
— Accesses (reads and writes) to volatile objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are not reordered with respect to other volatile accesses on the same thread.
— At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced....</p></div><footer class=entry-footer><span title='2023-12-02 18:12:37 +0800 CST'>December 2, 2023</span>&nbsp;·&nbsp;804 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observable Behaviors" href=https://yuang-chen.github.io/posts/2023-12-02-observable-behaviors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Trivial Class vs Aggregate Structure</h2></header><div class=entry-content><p>Trivial Class vs Aggregate Structure Trivial Class A trivial class is a class that:
Has a trivial default constructor. Has a trivial copy constructor. Has a trivial move constructor (since C++11). Has a trivial copy assignment operator. Has a trivial move assignment operator (since C++11). Has a trivial destructor. Has no virtual functions or virtual base classes. The trivial constructors/operations/destructor means they are not user-provided (i.e., is implicitly-defined or defaulted on its first declaration)....</p></div><footer class=entry-footer><span title='2023-11-01 15:10:00 +0800 CST'>November 1, 2023</span>&nbsp;·&nbsp;258 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trivial Class vs Aggregate Structure" href=https://yuang-chen.github.io/posts/2023-11-01-trivial-class-vs-aggregate-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Initialization With Brackets</h2></header><div class=entry-content><p>The table summarizes how brackets {} and () are related to list-initialization in various contexts. The column Allows Narrowing Conversion indicates whether implicit type conversions that lose information are allowed. The column Allows Explicit Constructors indicates whether the syntax can call constructors marked as explicit. The columns Use for Aggregates and Use for User-Defined Types show the applicability of each initialization type for aggregates like arrays (e.g., int x[3][4]) and structs, and user-defined types like classes, respectively....</p></div><footer class=entry-footer><span title='2023-10-29 15:03:28 +0800 CST'>October 29, 2023</span>&nbsp;·&nbsp;142 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Initialization With Brackets" href=https://yuang-chen.github.io/posts/2023-10-29-initialization-with-brackets/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Scope Guard</h2></header><div class=entry-content><p>Background Scope Guard is a concept reminiscent of the RAII (Resource Acquisition Is Initialization) principle in C++. The idea is to manage resources (like memory, files, network sockets, etc.) using object lifetime. When the object goes out of scope, its destructor ensures that the resource is cleaned up properly. The scope guard is intended to run a given callable (like a function or lambda) when it is destroyed.
RAII (Resource Acquisition Is Initialization) is a programming idiom used in C++ where the lifetime of an object is bound to the lifetime of its scope (typically represented by a block of code wrapped in curly braces {})....</p></div><footer class=entry-footer><span title='2023-08-29 10:27:54 +0800 CST'>August 29, 2023</span>&nbsp;·&nbsp;629 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scope Guard" href=https://yuang-chen.github.io/posts/2023-08-29-scope-guard/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Static Local Member</h2></header><div class=entry-content><p>C++ templates are blueprints and don’t represent specific types until they are instantiated with actual types. Once instantiated, the compiler creates a specific version of that template for the provided type. For template classes, each instantiation has its own unique version of the static members, making them distinct for each type the template is instantiated with.
///////////////////// // Code Block 1 ///////////////////// #include&lt;iostream> class ComponentBase{ protected: // component_type_count is a static variable shared by derived classes static inline size_t component_type_count = 0; }; template&lt;typename T> class Component : public ComponentBase{ public: static size_t component_type_id(){ // ID is the static local variable for a particular type T static size_t ID = component_type_count++; return ID; } }; class A : public Component&lt;A> {}; class B : public Component&lt;B> {}; class C : public Component&lt;C> {}; int main() { std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; B::component_type_id() &lt;&lt; std::endl; // 1 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; A::component_type_id() &lt;&lt; std::endl; // 0 std::cout &lt;&lt; C::component_type_id() &lt;&lt; std::endl; // 2 } Key Points:...</p></div><footer class=entry-footer><span title='2023-08-27 11:45:15 +0800 CST'>August 27, 2023</span>&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Static Local Member" href=https://yuang-chen.github.io/posts/2023-08-27-static-local-member/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Formatter Specialization</h2></header><div class=entry-content><p>We can customize the (printing) format of a given class by using the specialization of formatter.
#include &lt;format> #include &lt;iostream> struct Frac { int a, b; }; template &lt;> struct std::formatter&lt;Frac> : std::formatter&lt;string_view> { // parse() is inherited from the base class std::formatter&lt;string_view> // * an efficient solution: auto format(const Frac& frac, std::format_context& ctx) const { return std::format_to(ctx.out(), "{}/{}", frac.a, frac.b); } // the same functionality as above, but inefficient due to the temporary string // auto format(const Frac& frac, std::format_context& ctx) const { // std::string temp; // std::format_to(std::back_inserter(temp), "{}/{}", // frac....</p></div><footer class=entry-footer><span title='2023-08-25 19:56:16 +0800 CST'>August 25, 2023</span>&nbsp;·&nbsp;154 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Formatter Specialization" href=https://yuang-chen.github.io/posts/2023-08-25-formatter-specialization/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://yuang-chen.github.io/tags/c++/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>