<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Graph | Yac's Log</title><meta name=keywords content><meta name=description content="Blog"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/tags/graph/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/tags/graph/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Graph"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/tags/graph/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Graph"><meta name=twitter:description content="Blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Graph
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Approximate Densest Subgraph</h2></header><div class=entry-content><p>Note The Approximate Densest Subgraph problem involves finding a subgraph of a given graph that has the highest density, where density is typically defined as the number of edges divided by the number of vertices in the subgraph. Finding the exact densest subgraph is computationally expensive, so approximate solutions are often sought.
Here’s a high-level outline of how an approximate algorithm for this problem might be implemented:
Initialization: Start with all vertices of the graph and no edges....</p></div><footer class=entry-footer><span title='2024-01-26 11:36:24 +0800 HKT'>January 26, 2024</span>&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approximate Densest Subgraph" href=https://yuang-chen.github.io/posts/2024-01-26-approximate-densest-subgraph/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Maximal Independent Set</h2></header><div class=entry-content><p>Note An independent set in a graph is a set of vertices, no two of which are adjacent. A maximal independent set is an independent set that is not a subset of any other independent set in the graph. Here’s a basic approach to find a Maximal Independent Set:
Start with an empty set S. Iterate over all vertices of the graph. For each vertex: If the vertex and its neighbors are not in S, add the vertex to S....</p></div><footer class=entry-footer><span title='2023-12-13 11:00:10 +0800 HKT'>December 13, 2023</span>&nbsp;·&nbsp;338 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Maximal Independent Set" href=https://yuang-chen.github.io/posts/2023-12-13-maximal-independent-set/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Maximal Matching</h2></header><div class=entry-content><p>Note The Matching algorithm is a graph algorithm that finds a matching in a graph, where a matching is a set of edges without common vertices. In other words, a subset of the edges is a matching if each vertex appears in at most one edge of that matching.
A Maximal matching is a matching that cannot have any more edges added to it without violating the matching property.
A maximum matching is a matching that contains the largest possible number of edges....</p></div><footer class=entry-footer><span title='2023-12-05 23:21:43 +0800 HKT'>December 5, 2023</span>&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Maximal Matching" href=https://yuang-chen.github.io/posts/2023-12-05-maximal-matching/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Graph Coloring</h2></header><div class=entry-content><p>Note Graph coloring is a way of assigning colors to the vertices of a graph so that no two adjacent vertices share the same color. This is a classical problem in the field of graph theory and has applications in various domains like scheduling, map coloring, and solving Sudoku puzzles.
The simplest form of graph coloring is vertex coloring, where the aim is to minimize the number of colors used. This problem is NP-hard, meaning there is no known algorithm that can solve all instances of the problem efficiently (in polynomial time)....</p></div><footer class=entry-footer><span title='2023-11-29 10:17:23 +0800 HKT'>November 29, 2023</span>&nbsp;·&nbsp;350 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Graph Coloring" href=https://yuang-chen.github.io/posts/2023-11-29-graph-coloring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Biconnected Components</h2></header><div class=entry-content><p>Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.
Strict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component....</p></div><footer class=entry-footer><span title='2023-11-20 10:43:56 +0800 HKT'>November 20, 2023</span>&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Biconnected Components" href=https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Low Diameter Decomposition</h2></header><div class=entry-content><p>Note The Low-Diameter Decomposition (LDD) algorithm is a graph partitioning algorithm that decomposes a graph into several connected subgraphs (or components) such that each subgraph has a low diameter. The diameter of a subgraph is defined as the maximum shortest path distance between any two nodes within the subgraph.
The LDD algorithm works as follows:
Start with an empty decomposition and an empty queue. Pick an unvisited node u and create a new set containing only u....</p></div><footer class=entry-footer><span title='2023-11-02 19:04:28 +0800 HKT'>November 2, 2023</span>&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Low Diameter Decomposition" href=https://yuang-chen.github.io/posts/2023-11-02-low-diameter-decomposition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Strongly Connected Components</h2></header><div class=entry-content><p>Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.
Weakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the “default” CC algorithm, if there isn’t a specification for Strongly or Weakly.
Kosaraju’s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC....</p></div><footer class=entry-footer><span title='2023-10-12 11:54:29 +0800 HKT'>October 12, 2023</span>&nbsp;·&nbsp;820 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strongly Connected Components" href=https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Minimum Spanning Tree</h2></header><div class=entry-content><p>Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it’s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible....</p></div><footer class=entry-footer><span title='2023-09-29 10:34:39 +0800 HKT'>September 29, 2023</span>&nbsp;·&nbsp;824 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Minimum Spanning Tree" href=https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Triangle Counting</h2></header><div class=entry-content><p>count how many triangles can be formed inside the graph undirected graph, and each triangle would be counted for three times, once per node. $O(n^3)$ #include &lt;iostream> #include &lt;vector> // Reference: https://github.com/georgegito/vertexwise-triangle-counting/blob/master/src/v3/v3_seq.cpp // allow for parallelism auto bfs_tc(const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { int numTriangles = 0; const auto numVertices = rowPtr.size() - 1; // check if two nodes have an edge between them with binary search (require sorted colIdx) auto intersect = [&](int first, int second) -> bool { // std::find is O(N), assuming the iterator is a forward iterator // auto first_begin = colIdx....</p></div><footer class=entry-footer><span title='2023-09-23 17:09:51 +0800 HKT'>September 23, 2023</span>&nbsp;·&nbsp;311 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Triangle Counting" href=https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Betweenness Centrality</h2></header><div class=entry-content><p>The betweenness centrality for each vertex is the number of these shortest paths that pass through the vertex.
perform BFS (or SSSP if weighted graphs) for each vertex keep a stack of path for backtracking, i.e., traversing the graph in reverse BFS order #include &lt;iostream> #include &lt;queue> #include &lt;stack> #include &lt;vector> auto brandes(const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { const auto numVertices = rowPtr.size() - 1; std::vector&lt;float> betweenness(numVertices, 0.0f); //For each vertex s, perform a BFS to establish levels and predecessors //!...</p></div><footer class=entry-footer><span title='2023-09-18 17:12:24 +0800 HKT'>September 18, 2023</span>&nbsp;·&nbsp;392 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Betweenness Centrality" href=https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://yuang-chen.github.io/tags/graph/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>