<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Graph on Yac&#39;s Log</title>
    <link>https://yuang-chen.github.io/tags/graph/</link>
    <description>Recent content in Graph on Yac&#39;s Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Dec 2023 11:00:10 +0800</lastBuildDate><atom:link href="https://yuang-chen.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Maximal Independent Set</title>
      <link>https://yuang-chen.github.io/posts/2023-12-13-maximal-independent-set/</link>
      <pubDate>Wed, 13 Dec 2023 11:00:10 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-12-13-maximal-independent-set/</guid>
      <description>Maximal Independent Set An independent set in a graph is a set of vertices, no two of which are adjacent. A maximal independent set is an independent set that is not a subset of any other independent set in the graph. Here&amp;rsquo;s a basic approach to find a Maximal Independent Set:
Start with an empty set S. Iterate over all vertices of the graph. For each vertex: If the vertex and its neighbors are not in S, add the vertex to S.</description>
    </item>
    
    <item>
      <title>Maximal Matching</title>
      <link>https://yuang-chen.github.io/posts/2023-12-05-maximal-matching/</link>
      <pubDate>Tue, 05 Dec 2023 23:21:43 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-12-05-maximal-matching/</guid>
      <description>Maximal Matching The Matching algorithm is a graph algorithm that finds a matching in a graph, where a matching is a set of edges without common vertices. In other words, a subset of the edges is a matching if each vertex appears in at most one edge of that matching.
A Maximal matching is a matching that cannot have any more edges added to it without violating the matching property.</description>
    </item>
    
    <item>
      <title>Graph Coloring</title>
      <link>https://yuang-chen.github.io/posts/2023-11-29-graph-coloring/</link>
      <pubDate>Wed, 29 Nov 2023 10:17:23 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-11-29-graph-coloring/</guid>
      <description>Note Graph coloring is a way of assigning colors to the vertices of a graph so that no two adjacent vertices share the same color. This is a classical problem in the field of graph theory and has applications in various domains like scheduling, map coloring, and solving Sudoku puzzles.
The simplest form of graph coloring is vertex coloring, where the aim is to minimize the number of colors used. This problem is NP-hard, meaning there is no known algorithm that can solve all instances of the problem efficiently (in polynomial time).</description>
    </item>
    
    <item>
      <title>Biconnected Components</title>
      <link>https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/</link>
      <pubDate>Mon, 20 Nov 2023 10:43:56 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-11-20-biconnected-components/</guid>
      <description>Note Biconnectivity in graphs is an important concept used to identify biconnected components (BCCs). A graph is biconnected if it is connected and does not have any articulation points, meaning removing any single vertex will not disconnect the graph. The biconnected components of a graph are maximal biconnected subgraphs.
Strict Definition: A BCC should contain at least three vertices in a cycle, ensuring that the removal of any single vertex does not disconnect the component.</description>
    </item>
    
    <item>
      <title>Low Diameter Decomposition</title>
      <link>https://yuang-chen.github.io/posts/2023-11-02-low-diameter-decomposition/</link>
      <pubDate>Thu, 02 Nov 2023 19:04:28 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-11-02-low-diameter-decomposition/</guid>
      <description>Note The Low-Diameter Decomposition (LDD) algorithm is a graph partitioning algorithm that decomposes a graph into several connected subgraphs (or components) such that each subgraph has a low diameter. The diameter of a subgraph is defined as the maximum shortest path distance between any two nodes within the subgraph.
The LDD algorithm works as follows:
Start with an empty decomposition and an empty queue. Pick an unvisited node u and create a new set containing only u.</description>
    </item>
    
    <item>
      <title>Strongly Connected Components</title>
      <link>https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/</link>
      <pubDate>Thu, 12 Oct 2023 11:54:29 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-10-12-strongly-connected-components/</guid>
      <description>Description Strongly Connected Components operates the directed graph in which there is a directed path from each vertex to every other vertex.
Weakly Connected Component (the one we discussed before) ignores the direction of the edges. WCC is commonly considered the &amp;ldquo;default&amp;rdquo; CC algorithm, if there isn&amp;rsquo;t a specification for Strongly or Weakly.
Kosaraju&amp;rsquo;s Algorithm: Run 1st DFS to get finishing times of each vertex (i.e., postordering of DFS). [Backtracking] Run 2nd DFS on the transposed graph, starting with the visited vertices in Reverse Post-Order Each DFS tree in step 2 is an SCC.</description>
    </item>
    
    <item>
      <title>Minimum Spanning Tree</title>
      <link>https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/</link>
      <pubDate>Fri, 29 Sep 2023 10:34:39 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-29-minimum-spanning-tree/</guid>
      <description>Description A Minimum Spanning Tree (MST) of a weighted, connected, undirected graph is a tree that spans all the vertices in the graph and has the minimum possible total edge weight among all the trees that can be created from the graph. In simpler terms, it&amp;rsquo;s a subgraph that includes all the vertices, is a tree (meaning it has no cycles), and the sum of its edge weights is as small as possible.</description>
    </item>
    
    <item>
      <title>Triangle Counting</title>
      <link>https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/</link>
      <pubDate>Sat, 23 Sep 2023 17:09:51 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/</guid>
      <description>count how many triangles can be formed inside the graph undirected graph, and each triangle would be counted for three times, once per node. $O(n^3)$ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; // Reference: https://github.com/georgegito/vertexwise-triangle-counting/blob/master/src/v3/v3_seq.cpp // allow for parallelism auto bfs_tc(const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { int numTriangles = 0; const auto numVertices = rowPtr.size() - 1; // check if two nodes have an edge between them with binary search (require sorted colIdx) auto intersect = [&amp;amp;](int first, int second) -&amp;gt; bool { // std::find is O(N), assuming the iterator is a forward iterator // auto first_begin = colIdx.</description>
    </item>
    
    <item>
      <title>Betweenness Centrality</title>
      <link>https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/</link>
      <pubDate>Mon, 18 Sep 2023 17:12:24 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/</guid>
      <description>The betweenness centrality for each vertex is the number of these shortest paths that pass through the vertex.
perform BFS (or SSSP if weighted graphs) for each vertex keep a stack of path for backtracking, i.e., traversing the graph in reverse BFS order #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; auto brandes(const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { const auto numVertices = rowPtr.size() - 1; std::vector&amp;lt;float&amp;gt; betweenness(numVertices, 0.0f); //For each vertex s, perform a BFS to establish levels and predecessors //!</description>
    </item>
    
    <item>
      <title>Connected Components</title>
      <link>https://yuang-chen.github.io/posts/2023-09-12-connected-components/</link>
      <pubDate>Tue, 12 Sep 2023 12:32:15 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-12-connected-components/</guid>
      <description>Description Three different variants of Connected Component (CC) algorithms are implemented, and the comparisons are provided as follows:
Algorithm Time Complexity Parallelism Techniques DFS $(O(V + E))$ Poor Recursive Traversal Union-Find $(O(V + E \alpha(V)))$ Poor Path Compression, Union by Rank Shiloach-Vishkin $(O(\log^* V))$ Highly Parallel Pointer Jumping Here, $( \log^* )$ is the iterated logarithm, which is extremely slow-growing, making the algorithm very fast. $( \alpha(V) )$ is the inverse Ackermann function, practically a constant for all feasible input sizes.</description>
    </item>
    
    <item>
      <title>SSSP</title>
      <link>https://yuang-chen.github.io/posts/2023-09-09-sssp/</link>
      <pubDate>Sat, 09 Sep 2023 13:36:19 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-09-sssp/</guid>
      <description>Two variants of Single-Source Shortest Path (SSSP) have been implemented as follows. Bellman-Ford is the one that is widely implemented in parallel graph frameworks. This is because the use of a heap in Dijkstra&amp;rsquo;s algorithm can limit the parallelism of the code.
Criteria Dijkstra&amp;rsquo;s Algorithm Bellman-Ford Algorithm Type Greedy Dynamic Programming Usage Positive weights Negative weights OK Time Complexity O((V + E) * log(V)) O(V * E) Negative Cycles No Yes (Detectable) Data Structures Priority Queue None (Arrays) Initialization Start node: 0, rest ∞ Start node: 0, rest ∞ Relaxation Decrease Key Relaxation BellmanFord BellmanFord: Perform numVertices - 1 iterations of graph traversal to find the shortest path an additional iteration checks if negative cycles exist $O(|V| * |E|)$ time complexity Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;vector&amp;gt; std::vector&amp;lt;int&amp;gt; bellmanFord(const int root, const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx, const std::vector&amp;lt;float&amp;gt;&amp;amp; weight) { const auto numVertices = rowPtr.</description>
    </item>
    
    <item>
      <title>BFS &amp; DFS</title>
      <link>https://yuang-chen.github.io/posts/2023-09-01-bfs/</link>
      <pubDate>Fri, 01 Sep 2023 11:17:51 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-01-bfs/</guid>
      <description>Iterative BFS Despite its apparent simplicity, this approach relies heavily on the utilization of various STL containers. std::unordered_map records the parent of each node std::unordered_set checks if a node has been visited std::queue allows the nodes be accessed in the width-first flow; using std::stack for depth-first flow std::stack reverses the parents, so the path can be printed in root-to-target order. #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;unordered_map&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; std::stack&amp;lt;int&amp;gt; BFS(const int root, const int target, const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { std::unordered_map&amp;lt;int, int&amp;gt; parent; std::unordered_set&amp;lt;int&amp;gt; visited; std::queue&amp;lt;int&amp;gt; nodeQue; // std::stack&amp;lt;int&amp;gt; nodeStk for DFS std::stack&amp;lt;int&amp;gt; path; bool hasFound = false; nodeQue.</description>
    </item>
    
    <item>
      <title>Graph Algorithms</title>
      <link>https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/</link>
      <pubDate>Thu, 31 Aug 2023 18:12:09 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/</guid>
      <description>Considering myself a researcher in graph algorithms, I&amp;rsquo;ve come to the surprising realization that my grasp of these algorithms is not as solid as I thought. Hence, this blog series aims to document my exploration of various graph algorithms I&amp;rsquo;ve encountered thus far, regardless of their complexity.
The algorithms are selected from the parallel graph frameworks GAP and GBBS, focusing on their single-threaded versions to assess their complexity.
Breadth-First Search (BFS) Single-Source Shortest Paths (SSSP) Connected Components (CC) Betweenness Centrality (BC) Triangle Counting (TC) Minimum Spanning Tree (MST) Strongly Connected Components (SCC) SCAN Clustering (SCAN) Low Diameter Decomposition (LDD) Biconnected-Components (BC) Graph Coloring (COLOR) Maximal Matching (MM) Maximal Independent Set (MIS) </description>
    </item>
    
  </channel>
</rss>
