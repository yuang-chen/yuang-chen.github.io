<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Graph on Yac&#39;s Log</title>
    <link>https://yuang-chen.github.io/tags/graph/</link>
    <description>Recent content in Graph on Yac&#39;s Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Sep 2023 00:09:48 +0800</lastBuildDate><atom:link href="https://yuang-chen.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Set &amp; Map</title>
      <link>https://yuang-chen.github.io/posts/2023-09-26-set-map/</link>
      <pubDate>Tue, 26 Sep 2023 00:09:48 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-26-set-map/</guid>
      <description>Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it&amp;rsquo;s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left &amp;lt; node &amp;lt; node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.
RBT are characterized as follows:
Property
A node is either red or black.</description>
    </item>
    
    <item>
      <title>Triangle Counting</title>
      <link>https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/</link>
      <pubDate>Sat, 23 Sep 2023 17:09:51 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/</guid>
      <description>count how many triangles can be formed inside the graph undirected graph, and each triangle would be counted for three times, once per node. O(n^3) #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; // Reference: https://github.com/georgegito/vertexwise-triangle-counting/blob/master/src/v3/v3_seq.cpp // allow for parallelism auto bfs_tc(const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { int numTriangles = 0; const auto numVertices = rowPtr.size() - 1; // check if two nodes have an edge between them with binary search (require sorted colIdx) auto intersect = [&amp;amp;](int first, int second) -&amp;gt; bool { // std::find is O(N), assuming the iterator is a forward iterator // auto first_begin = colIdx.</description>
    </item>
    
    <item>
      <title>Betweenness Centrality</title>
      <link>https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/</link>
      <pubDate>Mon, 18 Sep 2023 17:12:24 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/</guid>
      <description>The betweenness centrality for each vertex is the number of these shortest paths that pass through the vertex.
perform BFS (or SSSP if weighted graphs) for each vertex keep a stack of path for backtracking, i.e., traversing the graph in reverse BFS order #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; auto brandes(const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { const auto numVertices = rowPtr.size() - 1; std::vector&amp;lt;float&amp;gt; betweenness(numVertices, 0.0f); //For each vertex s, perform a BFS to establish levels and predecessors //!</description>
    </item>
    
    <item>
      <title>SSSP</title>
      <link>https://yuang-chen.github.io/posts/2023-09-09-sssp/</link>
      <pubDate>Sat, 09 Sep 2023 13:36:19 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-09-sssp/</guid>
      <description>Two variants of Single-Source Shortest Path (SSSP) have been implemented as follows. Bellman-Ford is the one that is widely implemented in parallel graph frameworks. This is because the use of a heap in Dijkstra&amp;rsquo;s algorithm can limit the parallelism of the code.
Criteria Dijkstra&amp;rsquo;s Algorithm Bellman-Ford Algorithm Type Greedy Dynamic Programming Usage Positive weights Negative weights OK Time Complexity O((V + E) * log(V)) O(V * E) Negative Cycles No Yes (Detectable) Data Structures Priority Queue None (Arrays) Initialization Start node: 0, rest ∞ Start node: 0, rest ∞ Relaxation Decrease Key Relaxation BellmanFord BellmanFord: Perform numVertices - 1 iterations of graph traversal to find the shortest path an additional iteration checks if negative cycles exist $O(|V| * |E|)$ time complexity Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;vector&amp;gt; std::vector&amp;lt;int&amp;gt; bellmanFord(const int root, const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx, const std::vector&amp;lt;float&amp;gt;&amp;amp; weight) { const auto numVertices = rowPtr.</description>
    </item>
    
    <item>
      <title>BFS &amp; DFS</title>
      <link>https://yuang-chen.github.io/posts/2023-09-01-bfs/</link>
      <pubDate>Fri, 01 Sep 2023 11:17:51 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-09-01-bfs/</guid>
      <description>Iterative BFS Despite its apparent simplicity, this approach relies heavily on the utilization of various STL containers. std::unordered_map records the parent of each node std::unordered_set checks if a node has been visited std::queue allows the nodes be accessed in the width-first flow; using std::stack for depth-first flow std::stack reverses the parents, so the path can be printed in root-to-target order. #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;unordered_map&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;stack&amp;gt; std::stack&amp;lt;int&amp;gt; BFS(const int root, const int target, const std::vector&amp;lt;int&amp;gt;&amp;amp; rowPtr, const std::vector&amp;lt;int&amp;gt;&amp;amp; colIdx) { std::unordered_map&amp;lt;int, int&amp;gt; parent; std::unordered_set&amp;lt;int&amp;gt; visited; std::queue&amp;lt;int&amp;gt; nodeQue; // std::stack&amp;lt;int&amp;gt; nodeStk for DFS std::stack&amp;lt;int&amp;gt; path; bool hasFound = false; nodeQue.</description>
    </item>
    
    <item>
      <title>Graph Algorithms</title>
      <link>https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/</link>
      <pubDate>Thu, 31 Aug 2023 18:12:09 +0800</pubDate>
      
      <guid>https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/</guid>
      <description>Considering myself a researcher in graph algorithms, I&amp;rsquo;ve come to the surprising realization that my grasp of these algorithms is not as solid as I thought. Hence, this blog series aims to document my exploration of various graph algorithms I&amp;rsquo;ve encountered thus far, regardless of their complexity.
The algorithms are selected from the parallel graph frameworks GAP and GBBS, focusing on their single-threaded versions to assess their complexity.
Breadth-First Search (BFS) Single-Source Shortest Paths (SSSP) Connected Components (CC) Betweenness Centrality (BC) Triangle Counting (TC) </description>
    </item>
    
  </channel>
</rss>
