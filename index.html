<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Yac's Log</title><meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="Blog"><meta name=author content="Me"><link rel=canonical href=https://yuang-chen.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://yuang-chen.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuang-chen.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuang-chen.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://yuang-chen.github.io/favicon/apple-touch-icon.ico><link rel=mask-icon href=https://yuang-chen.github.io/favicon/favicon-32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuang-chen.github.io/index.xml><link rel=alternate type=application/json href=https://yuang-chen.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Yac's Log"><meta property="og:description" content="Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://yuang-chen.github.io/"><meta property="og:site_name" content="Yac's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Yac's Log"><meta name=twitter:description content="Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Yac's Log","url":"https://yuang-chen.github.io/","description":"Blog","thumbnailUrl":"https://yuang-chen.github.io/favicon/favicon.ico","sameAs":["https://www.linkedin.com/in/yuang-chen/","https://github.com/yuang-chen"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuang-chen.github.io/ accesskey=h title="Yac's Log (Alt + H)"><img src=https://yuang-chen.github.io/facebook alt aria-label=logo height=35>Yac's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuang-chen.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yuang-chen.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://yuang-chen.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yuang-chen.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yuang-chen.github.io/about/aboutme title=About><span>About</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Welcome 🧀</h1></header><div class=entry-content>Hi, this is YuAng. Here is where I compile my learning notes, exploring modern C++ and code performance.</div><footer class=entry-footer><div class=social-icons><a href=https://www.linkedin.com/in/yuang-chen/ target=_blank rel="noopener noreferrer me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a href=https://github.com/yuang-chen target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2>Set & Map</h2></header><div class=entry-content><p>Description Both std::set and std::map are underpinned by red-black trees (RBT). RBTs are self-balancing binary trees, albeit not perfectly balanced. In this structure, it’s ensured that the values (for std::set) or keys (for std::map) adhere to the following condition: node→left &lt; node &lt; node→right. Consequently, the RBT are considered ordered, so std::set and std::map are called ordered containers.
RBT are characterized as follows:
Property
A node is either red or black....</p></div><footer class=entry-footer><span title='2023-09-26 00:09:48 +0800 HKT'>September 26, 2023</span>&nbsp;·&nbsp;920 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Set & Map" href=https://yuang-chen.github.io/posts/2023-09-26-set-map/></a></article><article class=post-entry><header class=entry-header><h2>Triangle Counting</h2></header><div class=entry-content><p>count how many triangles can be formed inside the graph undirected graph, and each triangle would be counted for three times, once per node. O(n^3) #include &lt;iostream> #include &lt;vector> // Reference: https://github.com/georgegito/vertexwise-triangle-counting/blob/master/src/v3/v3_seq.cpp // allow for parallelism auto bfs_tc(const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { int numTriangles = 0; const auto numVertices = rowPtr.size() - 1; // check if two nodes have an edge between them with binary search (require sorted colIdx) auto intersect = [&](int first, int second) -> bool { // std::find is O(N), assuming the iterator is a forward iterator // auto first_begin = colIdx....</p></div><footer class=entry-footer><span title='2023-09-23 17:09:51 +0800 HKT'>September 23, 2023</span>&nbsp;·&nbsp;311 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Triangle Counting" href=https://yuang-chen.github.io/posts/2023-09-23-triangle-counting/></a></article><article class=post-entry><header class=entry-header><h2>Betweenness Centrality</h2></header><div class=entry-content><p>The betweenness centrality for each vertex is the number of these shortest paths that pass through the vertex.
perform BFS (or SSSP if weighted graphs) for each vertex keep a stack of path for backtracking, i.e., traversing the graph in reverse BFS order #include &lt;iostream> #include &lt;queue> #include &lt;stack> #include &lt;vector> auto brandes(const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { const auto numVertices = rowPtr.size() - 1; std::vector&lt;float> betweenness(numVertices, 0.0f); //For each vertex s, perform a BFS to establish levels and predecessors //!...</p></div><footer class=entry-footer><span title='2023-09-18 17:12:24 +0800 HKT'>September 18, 2023</span>&nbsp;·&nbsp;392 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Betweenness Centrality" href=https://yuang-chen.github.io/posts/2023-09-18-betweenness-centrality/></a></article><article class=post-entry><header class=entry-header><h2>Connected Components</h2></header><div class=entry-content><p>Description Three different variants of Connected Component (CC) algorithms are implemented, and the comparisons are provided as follows:
Algorithm Time Complexity Parallelism Techniques DFS $(O(V + E))$ Poor Recursive Traversal Union-Find $(O(V + E \alpha(V)))$ Poor Path Compression, Union by Rank Shiloach-Vishkin $(O(\log^* V))$ Highly Parallel Pointer Jumping Here, $( \log^* )$ is the iterated logarithm, which is extremely slow-growing, making the algorithm very fast. $( \alpha(V) )$ is the inverse Ackermann function, practically a constant for all feasible input sizes....</p></div><footer class=entry-footer><span title='2023-09-12 12:32:15 +0800 HKT'>September 12, 2023</span>&nbsp;·&nbsp;604 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Connected Components" href=https://yuang-chen.github.io/posts/2023-09-12-connected-components/></a></article><article class=post-entry><header class=entry-header><h2>List</h2></header><div class=entry-content><p>Description STL indeed offers std::list and std::forward_list, which are essentially double-linked list and single-linked list, respectively. std::list provides operations like push_back/front, pop_back/front with a time complexity of O(1), and supports bidirectional iterators. On the other hand, std::forward_list only allows fronting operations with O(1) and insert/erase_after for backing operations, which have a time complexity of O(n); also, it only supports forward iterators.
A valuable feature of lists is that they prohibit iterator invalidation compared to some other data structures....</p></div><footer class=entry-footer><span title='2023-09-11 16:33:34 +0800 HKT'>September 11, 2023</span>&nbsp;·&nbsp;707 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to List" href=https://yuang-chen.github.io/posts/2023-09-11-list/></a></article><article class=post-entry><header class=entry-header><h2>SSSP</h2></header><div class=entry-content><p>Two variants of Single-Source Shortest Path (SSSP) have been implemented as follows. Bellman-Ford is the one that is widely implemented in parallel graph frameworks. This is because the use of a heap in Dijkstra’s algorithm can limit the parallelism of the code.
Criteria Dijkstra’s Algorithm Bellman-Ford Algorithm Type Greedy Dynamic Programming Usage Positive weights Negative weights OK Time Complexity O((V + E) * log(V)) O(V * E) Negative Cycles No Yes (Detectable) Data Structures Priority Queue None (Arrays) Initialization Start node: 0, rest ∞ Start node: 0, rest ∞ Relaxation Decrease Key Relaxation BellmanFord BellmanFord: Perform numVertices - 1 iterations of graph traversal to find the shortest path an additional iteration checks if negative cycles exist $O(|V| * |E|)$ time complexity Code #include &lt;iostream> #include &lt;queue> #include &lt;vector> std::vector&lt;int> bellmanFord(const int root, const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx, const std::vector&lt;float>& weight) { const auto numVertices = rowPtr....</p></div><footer class=entry-footer><span title='2023-09-09 13:36:19 +0800 HKT'>September 9, 2023</span>&nbsp;·&nbsp;845 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SSSP" href=https://yuang-chen.github.io/posts/2023-09-09-sssp/></a></article><article class=post-entry><header class=entry-header><h2>Deque</h2></header><div class=entry-content><p>Description std::deque extends the interfaces of std::vector with push_front, pop_front, etc., such that elements can be inserted or removed at the end or beginning at constant time.
I’ve hardly ever incorporated std::deque in my own coding projects, and it’s a rarity in other people’s work as well.
Code std::deque is essentially a sequence of individually allocated fixed-size arrays. The real challenge lies in the bookkeeping. Four variables are relied on to keep track of data:...</p></div><footer class=entry-footer><span title='2023-09-04 21:53:31 +0800 HKT'>September 4, 2023</span>&nbsp;·&nbsp;1309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deque" href=https://yuang-chen.github.io/posts/2023-09-04-deque/></a></article><article class=post-entry><header class=entry-header><h2>Vector & Array</h2></header><div class=entry-content><p>Array is allocated in stack memory Vector is allocated in heap memory. Its capacity is “pre-allocated”. #include &lt;iostream> template&lt;typename T> class Vector { private: T* data_; size_t size_; size_t capacity_; public: Vector(): data_(nullptr), size_(0), capacity_(0) {} Vector(size_t n_): size_(n_), capacity_(n_) { data_ = new T[n_]; } ~Vector() { delete [] data_; }; T& operator[] (size_t index) { return data_[index]; } const T& operator[] (size_t index) const { return data_[index]; } size_t size() const { return size_; } void push_back(const T& value) { if(size_ == capacity_) { capacity_ = size_ == 0?...</p></div><footer class=entry-footer><span title='2023-09-02 10:59:59 +0800 HKT'>September 2, 2023</span>&nbsp;·&nbsp;202 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Vector & Array" href=https://yuang-chen.github.io/posts/2023-09-02-vector-array/></a></article><article class=post-entry><header class=entry-header><h2>BFS & DFS</h2></header><div class=entry-content><p>Iterative BFS Despite its apparent simplicity, this approach relies heavily on the utilization of various STL containers. std::unordered_map records the parent of each node std::unordered_set checks if a node has been visited std::queue allows the nodes be accessed in the width-first flow; using std::stack for depth-first flow std::stack reverses the parents, so the path can be printed in root-to-target order. #include &lt;iostream> #include &lt;vector> #include &lt;unordered_map> #include &lt;unordered_set> #include &lt;queue> #include &lt;stack> std::stack&lt;int> BFS(const int root, const int target, const std::vector&lt;int>& rowPtr, const std::vector&lt;int>& colIdx) { std::unordered_map&lt;int, int> parent; std::unordered_set&lt;int> visited; std::queue&lt;int> nodeQue; // std::stack&lt;int> nodeStk for DFS std::stack&lt;int> path; bool hasFound = false; nodeQue....</p></div><footer class=entry-footer><span title='2023-09-01 11:17:51 +0800 HKT'>September 1, 2023</span>&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BFS & DFS" href=https://yuang-chen.github.io/posts/2023-09-01-bfs/></a></article><article class=post-entry><header class=entry-header><h2>Graph Algorithms</h2></header><div class=entry-content><p>Considering myself a researcher in graph algorithms, I’ve come to the surprising realization that my grasp of these algorithms is not as solid as I thought. Hence, this blog series aims to document my exploration of various graph algorithms I’ve encountered thus far, regardless of their complexity.
The algorithms are selected from the parallel graph frameworks GAP and GBBS, focusing on their single-threaded versions to assess their complexity.
Breadth-First Search (BFS) Single-Source Shortest Paths (SSSP) Connected Components (CC) Betweenness Centrality (BC) Triangle Counting (TC)</p></div><footer class=entry-footer><span title='2023-08-31 18:12:09 +0800 HKT'>August 31, 2023</span>&nbsp;·&nbsp;84 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Graph Algorithms" href=https://yuang-chen.github.io/posts/2023-08-31-graph-algorithms/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://yuang-chen.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://yuang-chen.github.io/>Yac's Log</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>